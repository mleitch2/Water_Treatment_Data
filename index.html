<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Water Treatment Professionals</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
  <script src="https://js.arcgis.com/4.33/"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      box-sizing: border-box;
      overflow: hidden;
    }
    #mainAppContainer {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }
    #mainContent {
      flex: 1;
      display: flex;
      flex-direction: row;
      flex: 1;
      min-width: 0;
      min-height: 0;
      position: relative;
      z-index: 1;
    }
    #manipulatorPane {
      width: 420px;
      max-width: 90vw;
      background: #f5f2e6;
      border-left: 1px solid #ccc;
      box-shadow: -2px 0 6px rgba(0,0,0,0.04);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      padding: 0;
      z-index: 10;
      min-width: 300px;
      transition: width 0.2s;
      overflow-y: auto;
    }
    #manipulatorCloseBtn {
      background: none;
      border: none;
      font-size: 22px;
      color: #888;
      cursor: pointer;
    }
    #toolbox {
      display: flex;
      flex-direction: row;
      align-items: center;
      background: #034d46;
      padding: 4px 8px;
      gap: 8px;
      z-index: 10;
      height: 44px;
      min-height: 36px;
      max-height: 48px;
      box-shadow: 0 2px 4px rgba(23, 100, 36, 0.788);
      position: relative;
    }
    #mapLegend {
      background: #f5f2e6;
      padding: 12px 16px 14px 16px;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.13);
      font-size: 14px;
      color: #222;
      max-height: 340px;
      overflow-y: auto;
      width: 290px;
      display: none; 
    }
    #mapLegend::-webkit-scrollbar { width: 10px; }
    #mapLegend::-webkit-scrollbar-track { background: #efe9d3; border-radius: 10px; }
    #mapLegend::-webkit-scrollbar-thumb { background: #c9c1aa; border-radius: 10px; }
    #mapLegend::-webkit-scrollbar-thumb:hover { background: #b3aa93; }
  </style>
</head>
<body>
  <div id="mainAppContainer" style="display: flex; flex-direction: column; height: 100vh; width: 100vw;">
  <div id="toolbox">
      <div style="position: relative;">
        <button id="layersBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Layers ▼</button>
        <div id="layersDropdown" style="display: none; position: absolute; top: 36px; left: 0; background: #fff; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); min-width: 220px; z-index: 100; padding: 8px 12px;">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <input type="checkbox" id="chkProfessionals" checked>
            Water Treatment Professionals
          </label>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <input type="checkbox" id="chkBlueTriangles">
            Water Facilities
          </label>
          
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="chkCounties">
            US Counties
          </label>
          <label style="display: flex; align-items: center; gap: 8px; margin-top: 6px;">
            <input type="checkbox" id="chkPostalCodes">
            USA Postal Codes
          </label>
  </div>
  </div>
      <div style="position: relative;">
        <button id="legendBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Legend</button>
      </div>
      <div style="position: relative;">
        <button id="filterBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Filter Professional Group</button>
      </div>
      <div style="position: relative;">
        <button id="advancedSelectionBtn" style="padding: 6px 14px; background: #fff; color: #034d46; border-radius: 4px; border: none; font-weight: bold; cursor: pointer;">Advanced Selection</button>
      </div>
  <div id="searchBarsContainer" style="display:flex; flex-direction:row; align-items:center; flex:0 0 auto; gap:40px;">
        <div style="position:relative; flex:0 0 380px; min-width:300px;">
          <input id="searchBox" type="text" placeholder="Search all layers..." style="width:100%; padding:6px 12px; border-radius:4px; border:1px solid #ccc; font-size:15px;" autocomplete="off" />
          <div id="searchSuggestions" style="display:none; position:absolute; top:36px; left:0; right:0; background:#fff; border:1px solid #ccc; border-radius:4px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:200; max-height:320px; overflow-y:auto;"></div>
        </div>
  <div id="secondarySearchWrapper" style="display:flex; flex:0 0 340px; min-width:260px; align-items:center; gap:8px; justify-content:flex-start;">
        </div>
      </div>
    </div>
    <div id="mainContent" style="flex: 1; display: flex; flex-direction: row; min-height: 0; min-width: 0;">
      <div id="viewDiv" style="flex: 1; min-width: 0; min-height: 0; position: relative; z-index: 1;"></div>
      <div id="manipulatorPane" style="width: 420px; max-width: 90vw; background: #f5f2e6; border-left: 1px solid #ccc; box-shadow: -2px 0 6px rgba(0,0,0,0.04); display: none; flex-direction: column; align-items: stretch; padding: 0; z-index: 10; min-width: 300px; transition: width 0.2s; overflow-y: auto;">
        <div id="manipulatorHeader" style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #e0e0e0;">
          <span style="font-weight: bold; font-size: 17px; color: #1a3a5b;">Manipulator Pane</span>
          <button id="manipulatorCloseBtn" style="background: none; border: none; font-size: 22px; color: #888; cursor: pointer;">&times;</button>
        </div>
        <div id="manipulatorContent" style="padding: 18px 16px; color: #222; font-size: 15px;"></div>
      </div>
      <div id="advancedSelectionPane" style="width: 340px; max-width: 80vw; background:#f5f2e6; border-left:1px solid #ccc; box-shadow:-2px 0 6px rgba(0,0,0,0.04); display:none; flex-direction:column; align-items:stretch; padding:0; z-index:11; min-width:280px; transition: width 0.2s; overflow-y:auto;">
        <div style="display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid #e0e0e0;">
          <span style="font-weight:bold; font-size:17px; color:#1a3a5b;">Advanced Selection</span>
          <button id="advancedSelectionCloseBtn" style="background:none; border:none; font-size:22px; color:#888; cursor:pointer;">&times;</button>
        </div>
        <div style="padding:18px 16px; color:#222; font-size:14px;" id="advancedSelectionContent">
          <div style="font-size:13px; line-height:1.4; margin-bottom:14px; color:#333;">Draw a shape to select only Water Treatment Professionals currently visible (filters respected). Right-click or Esc to cancel drawing.</div>
          <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px;">
            <button id="btnSquareSelect" style="padding:6px 14px; background:#034d46; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Square</button>
            <button id="btnLassoSelect" style="padding:6px 14px; background:#034d46; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Lasso</button>
            <button id="btnClearSelection" style="padding:6px 14px; background:#888; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Clear</button>
          </div>
          <div style="margin:14px 0 10px 0; border-top:1px solid #d2cbb9; padding-top:12px; font-weight:bold; color:#1a3a5b;">ZIP Radius Selection</div>
          <div style="font-size:12px; color:#444; line-height:1.4; margin-bottom:8px;">Enter a 5-digit ZIP Code and a radius (miles). The map will zoom to the ZIP centroid and select Professionals & Blue Triangles within the radius.</div>
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:flex-end; margin-bottom:10px;">
            <div style="display:flex; flex-direction:column;">
              <label for="zipSelectInput" style="font-size:11px; font-weight:600; color:#333; letter-spacing:0.3px;">ZIP Code</label>
              <input id="zipSelectInput" maxlength="10" placeholder="e.g. 30309" style="padding:6px 8px; border:1px solid #bbb; border-radius:4px; width:110px; font-size:13px;" />
            </div>
            <div style="display:flex; flex-direction:column;">
              <label for="zipRadiusInput" style="font-size:11px; font-weight:600; color:#333; letter-spacing:0.3px;">Miles</label>
              <input id="zipRadiusInput" type="number" min="0.1" step="0.1" placeholder="10" style="padding:6px 8px; border:1px solid #bbb; border-radius:4px; width:90px; font-size:13px;" />
            </div>
            <button id="btnZipRadiusGo" style="padding:7px 14px; background:#034d46; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Go</button>
          </div>
          <div id="zipRadiusStatus" style="font-size:12px; color:#555; min-height:16px; margin-bottom:4px;"></div>
          <div style="margin:18px 0 10px 0; border-top:1px solid #d2cbb9; padding-top:12px; font-weight:bold; color:#1a3a5b;">Point Radius Selection</div>
          <div style="font-size:12px; color:#444; line-height:1.4; margin-bottom:8px;">Activate, then click anywhere on the map to set the center. Enter miles and press Go to select all Professionals & Blue Triangles within that radius.</div>
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:flex-end; margin-bottom:10px;">
            <button id="btnActivatePointCenter" style="padding:6px 12px; background:#034d46; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Activate</button>
            <div style="display:flex; flex-direction:column;">
              <label for="pointRadiusInput" style="font-size:11px; font-weight:600; color:#333; letter-spacing:0.3px;">Miles</label>
              <input id="pointRadiusInput" type="number" min="0.1" step="0.1" placeholder="10" style="padding:6px 8px; border:1px solid #bbb; border-radius:4px; width:90px; font-size:13px;" />
            </div>
            <button id="btnPointRadiusGo" style="padding:6px 14px; background:#034d46; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Go</button>
            <button id="btnClearPointCenter" style="padding:6px 14px; background:#888; color:#fff; border:none; border-radius:4px; cursor:pointer; font-weight:600;">Clear Center</button>
          </div>
          <div id="pointRadiusStatus" style="font-size:12px; color:#555; min-height:16px; margin-bottom:6px;"></div>
          <div id="advancedSelectionStatus" style="font-size:13px; color:#555;"></div>
          <div style="margin:22px 0 6px 0; border-top:1px solid #d2cbb9; padding-top:12px; font-weight:bold; color:#1a3a5b; display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:8px;">
            <span>Water Company Selection</span>
            <span style="display:flex; gap:6px;">
              <button id="wcCheckAllBtn" style="padding:4px 10px; background:#034d46; color:#fff; border:none; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600;">Check All</button>
              <button id="wcClearAllBtn" style="padding:4px 10px; background:#b80000; color:#fff; border:none; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600;">Clear All</button>
              <button id="wcApplyBtn" style="padding:4px 10px; background:#0b639d; color:#fff; border:none; border-radius:4px; font-size:11px; cursor:pointer; font-weight:600;">Apply</button>
            </span>
          </div>
          <div id="waterCompanySelection" style="max-height:260px; overflow-y:auto; background:#fff; border:1px solid #ccb; border-radius:4px; padding:8px 10px;">
            <div style="display:flex; flex-direction:column; gap:8px; font-size:13px;">
              <div style="display:flex; flex-direction:column; gap:4px; padding:4px 6px; background:#f4f7f9; border:1px solid #dde3e8; border-radius:4px;">
                <span style="font-weight:600;">Water treatment services?</span>
                <div style="display:flex; gap:14px; font-size:12px; padding-left:4px;">
                  <label style="display:flex; align-items:center; gap:4px;"><input type="radio" name="wcServiceYN" value="YES" /> Yes</label>
                  <label style="display:flex; align-items:center; gap:4px;"><input type="radio" name="wcServiceYN" value="NO" /> No</label>
                  <label style="display:flex; align-items:center; gap:4px;"><input type="radio" name="wcServiceYN" value="ANY" checked /> Any</label>
                </div>
              </div>
              <div style="text-align:center; font-weight:700; margin:6px 0 4px 0; font-size:13px;">Water Treatment Capabilities</div>
              <label><input type="checkbox" class="wc-opt" value="HVAC water treatment services" /> HVAC water treatment services</label>
              <label><input type="checkbox" class="wc-opt" value="Cooling Water Treatment services" /> Cooling Water Treatment services</label>
              <label><input type="checkbox" class="wc-opt" value="Heating/boiler water treatment service" /> Heating/boiler water treatment service</label>
              <label><input type="checkbox" class="wc-opt" value="Filtration/separation or Reverse Osmosis water treatment services" /> Filtration/separation or Reverse Osmosis water treatment services</label>
              <label><input type="checkbox" class="wc-opt" value="Ultrapure water treatment" /> Ultrapure water treatment</label>
              <label><input type="checkbox" class="wc-opt" value="Wastewater treatment" /> Wastewater treatment</label>
              <label><input type="checkbox" class="wc-opt" value="Glycol" /> Glycol</label>
              <label><input type="checkbox" class="wc-opt" value="Cleaning / Sanitization / Disinfection" /> Cleaning / Sanitization / Disinfection</label>
              <label><input type="checkbox" class="wc-opt" value="Legionella or other regulatory testing" /> Legionella or other regulatory testing</label>
              <div style="text-align:center; font-weight:700; margin:6px 0 4px 0; font-size:13px;">Blending/chemistry capabilities</div>
              <label><input type="checkbox" class="wc-opt" value="Chemical Blending, specialty formulation, private label for water treatment" /> Chemical Blending, specialty formulation, private label for water treatment</label>
              <div style="text-align:center; font-weight:700; margin:6px 0 4px 0; font-size:13px;">Equipment capabilities</div>
              <label><input type="checkbox" class="wc-opt" value="Manufacturing or assembly: Pumps / Controls / sensors" /> Manufacturing or assembly: Pumps / Controls / sensors</label>
              <label><input type="checkbox" class="wc-opt" value="Installation and/or maintenance: Pumps / Controls / sensors" /> Installation and/or maintenance: Pumps / Controls / sensors</label>
              <label><input type="checkbox" class="wc-opt" value="Manufacturing or assembly: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators" /> Manufacturing or assembly: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators</label>
              <label><input type="checkbox" class="wc-opt" value="Installation and/or maintenance: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators" /> Installation and/or maintenance: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators</label>
              <div style="text-align:center; font-weight:700; margin:6px 0 4px 0; font-size:13px;">Industries/Customers served</div>
              <label><input type="checkbox" class="wc-opt" value="Commercial / office / apartment / warehouse facilities - general" /> Commercial / office / apartment / warehouse facilities - general</label>
              <label><input type="checkbox" class="wc-opt" value="Hospitality, e.g., hotels and restaurants" /> Hospitality, e.g., hotels and restaurants</label>
              <label><input type="checkbox" class="wc-opt" value="Healthcare / hospitals" /> Healthcare / hospitals</label>
              <label><input type="checkbox" class="wc-opt" value="Education / schools + universities" /> Education / schools + universities</label>
              <label><input type="checkbox" class="wc-opt" value="Government facilities" /> Government facilities</label>
              <label><input type="checkbox" class="wc-opt" value="Industrial or Manufacturing facilities - general" /> Industrial or Manufacturing facilities - general</label>
              <label><input type="checkbox" class="wc-opt" value="Pharmaceutical manufacturing" /> Pharmaceutical manufacturing</label>
              <label><input type="checkbox" class="wc-opt" value="Data centers" /> Data centers</label>
              <label><input type="checkbox" class="wc-opt" value="Food and/or beverage processing + manufacture" /> Food and/or beverage processing + manufacture</label>
              <label><input type="checkbox" class="wc-opt" value="Agriculture - general" /> Agriculture - general</label>
              <label><input type="checkbox" class="wc-opt" value="Agriculture - irrigation, crops" /> Agriculture - irrigation, crops</label>
              <label><input type="checkbox" class="wc-opt" value="Agriculture - livestock / aquaculture" /> Agriculture - livestock / aquaculture</label>
              <label><input type="checkbox" class="wc-opt" value="Municipal / Public drinking water" /> Municipal / Public drinking water</label>
              <label><input type="checkbox" class="wc-opt" value="Municipal / Public wastewater" /> Municipal / Public wastewater</label>
              <label><input type="checkbox" class="wc-opt" value="Plumbing / HVAC contractors" /> Plumbing / HVAC contractors</label>
              <label><input type="checkbox" class="wc-opt" value="Domestic / non-commercial residential" /> Domestic / non-commercial residential</label>
              <div style="text-align:center; font-weight:700; margin:6px 0 4px 0; font-size:13px;">Other Serevices</div>
              <label><input type="checkbox" class="wc-opt" value="Lab services" /> Lab services</label>
              <label><input type="checkbox" class="wc-opt" value="Engineering design" /> Engineering design</label>
            </div>
          </div>
        </div>
      </div>
  <div id="mapLegend"></div>
    </div>
  </div>
  <script>
    let professionalsData = [];
    let blueTrianglesData = [];
    


    require([
      "esri/Map", "esri/views/MapView", "esri/layers/FeatureLayer", "esri/layers/GeoJSONLayer", "esri/Graphic", "esri/geometry/Point", "esri/geometry/geometryEngine"
    ], function (
      EsriMap, MapView, FeatureLayer, GeoJSONLayer, Graphic, Point, geometryEngine
    ) {
      let map, view;
      let professionalsLayerRef = null;
      let countiesLayerRef = null;
  let blueTrianglesLayerRef = null;
  let statesLayerRef = null; 
  let dynamicStateExtents = null; 
  let waterCompanyServiceField = null;
  let waterCompanyServiceAliasField = '_ServiceYN';
      
  let postalCodesLayerRef = null;

      const countiesGeoJsonUrl = "https://raw.githubusercontent.com/mleitch2/Water_Treatment_Data/main/US_Counties.geojson";
      const countiesLayer = new GeoJSONLayer({
        url: countiesGeoJsonUrl,
        title: "US Counties",
        opacity: 1,
        minScale: 15000000,
        renderer: {
          type: "simple",
          symbol: {
            type: "simple-fill",
            color: [0, 0, 0, 0],
            outline: { color: "#000000", width: 1 }
          }
        },
        labelingInfo: [
          {
            minScale: 4000000,
            labelExpressionInfo: { expression: '$feature.FIPS' },
            symbol: {
              type: "text",
              color: "#222",
              haloColor: "orange",
              haloSize: "1.5px",
              font: { family: "Arial", size: 12, weight: "bold" }
            },
            labelPlacement: "always-horizontal"
          }
        ],
        popupTemplate: {
          title: "{NAME}",
          content: "County: {County Name}<br>FIPS: {5-digit FIPS Code}"
        }
      });
      countiesLayer.visible = false;
      countiesLayerRef = countiesLayer;

      map = new EsriMap({ basemap: "topo-vector" });
      view = new MapView({ container: "viewDiv", map: map, center: [-95.671, 39.049], zoom: 5 });
      try {
        const statesGeoJsonUrl = "https://raw.githubusercontent.com/Link0923/Water_Treatment_Data/refs/heads/main/USA_State_Bounds.geojson";
        fetch(statesGeoJsonUrl).then(r => r.json()).then(geojson => {
          const feats = geojson && geojson.features ? geojson.features : [];
          const hasGeometry = feats.some(f => f.geometry && f.geometry.coordinates);
          if (!hasGeometry) {
            console.warn('[States] Provided GeoJSON has null geometries; skipping layer creation. Using static extents only.');
            return; 
          }
          dynamicStateExtents = {};
          feats.forEach(f => {
            const attrs = f.properties || {};
            const abbr = attrs.STATE_ABBR;
            if (!abbr || !f.geometry) return;
            const type = f.geometry.type;
            let coords = f.geometry.coordinates;
            function traverse(arr, cb){
              if (typeof arr[0] === 'number') { cb(arr); return; }
              arr.forEach(a => traverse(a, cb));
            }
            let xmin=Infinity,ymin=Infinity,xmax=-Infinity,ymax=-Infinity;
            traverse(coords, c => {
              const x=c[0], y=c[1];
              if (x < xmin) xmin = x; if (x > xmax) xmax = x; if (y < ymin) ymin = y; if (y > ymax) ymax = y;
            });
            if (isFinite(xmin)) {
              dynamicStateExtents[abbr.toUpperCase()] = [xmin,ymin,xmax,ymax];
            }
          });
          console.log('[States] Dynamic extents (raw parse) built for', Object.keys(dynamicStateExtents).length,'states');
          statesLayerRef = new GeoJSONLayer({
            url: statesGeoJsonUrl,
            title: 'US States (Hidden)',
            visible: false,
            outFields: ['STATE_ABBR','State Name'],
            renderer: { type:'simple', symbol:{ type:'simple-fill', color:[0,0,0,0], outline:{ color:'#666', width:0.5 } } }
          });
          map.add(statesLayerRef);
        }).catch(err => console.warn('Failed to fetch states GeoJSON', err));
      } catch (e) { console.warn('Failed to init custom states GeoJSON layer', e); }

      const legendNode = document.getElementById('mapLegend');
      view.ui.add({
        component: legendNode,
        position: 'top-left',
        index: 1
      });
      map.add(countiesLayer, 0);

      const usa_postal_codes = new FeatureLayer({
        portalItem: { id: "d6f7ee6129e241cc9b6f75978e47128b" },
        title: "USA Postal Codes",
        minScale: 15000000,
        renderer: {
          type: "simple",
          symbol: {
            type: "simple-fill",
            color: [0, 0, 0, 0],
            outline: { color: "#98E600", width: 1 }
          }
        },
        labelingInfo: [
          {
            minScale: 4000000,
            labelExpressionInfo: { expression: '$feature.ZIP_CODE' },
            symbol: {
              type: "text",
              color: "#222",
              haloColor: "red",
              haloSize: "1.5px",
              font: { family: "Arial", size: 12, weight: "bold" }
            },
            labelPlacement: "always-horizontal"
          }
        ]
      });
      usa_postal_codes.visible = false;
      postalCodesLayerRef = usa_postal_codes;
      map.add(usa_postal_codes, 1);

      let _countyShadeInFlight = null;
      let _countyFipsField = 'FIPS'; 
      async function detectCountyFipsField() {
        if (!_countyFipsField && countiesLayerRef && countiesLayerRef.fields) {
          const candidates = ['FIPS','fipscode','GEOID','FIPS_CODE','FIPSCode','STATE_FIPS'];
          for (const c of candidates) {
            if (countiesLayerRef.fields.find(f => f.name.toLowerCase() === c.toLowerCase())) { _countyFipsField = c; break; }
          }
        } else if (countiesLayerRef && countiesLayerRef.fields) {
          if (!countiesLayerRef.fields.find(f => f.name.toLowerCase() === _countyFipsField.toLowerCase())) {
            // fallback search
            const maybe = countiesLayerRef.fields.find(f => /fips/i.test(f.name));
            if (maybe) _countyFipsField = maybe.name;
          }
        }
      }
      async function updateCountyShading() {
        if (!professionalsLayerRef || !countiesLayerRef || !view) return;
        if (!professionalsLayerRef.visible || !countiesLayerRef.visible) return;
        await detectCountyFipsField();
        const thisRun = Symbol('countyRun');
        _countyShadeInFlight = thisRun;
        let query = professionalsLayerRef.createQuery();
        query.geometry = view.extent;
        query.spatialRelationship = 'intersects';
        query.where = professionalsLayerRef.definitionExpression || '1=1';
        const candidateFipsFields = ['FIPS','FIPS_5Digit','5_digit_FIPS_Code','FIPS_Code','fips'];
        const existing = (professionalsLayerRef.fields || []).map(f => f.name.toLowerCase());
        const safeOutFields = candidateFipsFields.filter(f => existing.includes(f.toLowerCase()));
        if (!safeOutFields.length) {
          console.warn('No FIPS-like fields present on professionals layer; county shading will skip.');
          return;
        }
        query.outFields = safeOutFields;
        query.returnGeometry = false;
        console.debug('County shading querying outFields:', query.outFields);
        let result;
        try { result = await professionalsLayerRef.queryFeatures(query); } catch (e) { console.warn('County shading query failed', e); return; }
        if (_countyShadeInFlight !== thisRun) return;
        const countyCounts = {};
        const extractionOrder = candidateFipsFields.filter(f => query.outFields.includes(f));
        for (const f of result.features) {
          const attrs = f.attributes || {};
          let fips = '';
          for (const k of extractionOrder) {
            if (attrs[k] != null && attrs[k] !== '') { fips = attrs[k]; break; }
          }
          if (typeof fips === 'number') fips = fips.toString();
          if (typeof fips === 'string') {
            fips = fips.trim();
            if (/^\d+$/.test(fips)) {
              if (fips.length < 5) fips = fips.padStart(5,'0');
            }
          }
          if (fips) countyCounts[fips] = (countyCounts[fips] || 0) + 1;
        }
        const counts = Object.values(countyCounts);
        if (!counts.length) {
          console.info('No professional points within extent for county shading. Resetting counties to neutral outline.');
          countiesLayerRef.renderer = {
            type: 'simple',
            symbol: { type: 'simple-fill', color: [0,0,0,0], outline: { color: '#000', width: 1 } }
          };
          try {
            countiesLayerRef.labelingInfo = [
              {
                minScale: 4000000,
                labelExpressionInfo: { expression: `$feature.${_countyFipsField}` },
                symbol: { type: 'text', color: '#555', haloColor: 'white', haloSize: '1px', font: { family: 'Arial', size: 11, weight: 'bold' } },
                labelPlacement: 'always-horizontal'
              }
            ];
          } catch(e) {}
          if (mapLegend && mapLegend.style.display === 'block') { try { updateLegend(); } catch(e) {} }
          return;
        }
        console.debug('Detected county FIPS field:', _countyFipsField, 'Distinct county codes counted:', Object.keys(countyCounts).length);
        const minCount = Math.min(...counts);
        const maxCount = Math.max(...counts);
        const colorRamp = [ [230,210,255], [120,0,180] ];
        function interp(val) {
          const t = (maxCount === minCount) ? 0 : (val - minCount) / (maxCount - minCount);
          return [
            Math.round(colorRamp[0][0] + t * (colorRamp[1][0] - colorRamp[0][0])),
            Math.round(colorRamp[0][1] + t * (colorRamp[1][1] - colorRamp[0][1])),
            Math.round(colorRamp[0][2] + t * (colorRamp[1][2] - colorRamp[0][2]))
          ];
        }
        const uniqueValueInfos = Object.entries(countyCounts).map(([fips, count]) => ({
          value: fips,
          symbol: { type: 'simple-fill', color: interp(count), outline: { color: '#000', width: 1 } },
          label: `${fips} (${count})`
        }));
        countiesLayerRef.renderer = {
          type: 'unique-value',
          field: _countyFipsField || 'FIPS',
          uniqueValueInfos,
          defaultSymbol: { type: 'simple-fill', color: [240,240,240,0.1], outline: { color: '#000', width: 1 } },
          defaultLabel: 'No data'
        };
        try {
          countiesLayerRef.labelingInfo = [
            {
              minScale: 4000000,
              labelExpressionInfo: { expression: `$feature.${_countyFipsField}` },
              symbol: {
                type: 'text',
                color: '#222',
                haloColor: 'orange',
                haloSize: '1.5px',
                font: { family: 'Arial', size: 12, weight: 'bold' }
              },
              labelPlacement: 'always-horizontal'
            }
          ];
        } catch (e) {}
        if (mapLegend && mapLegend.style.display === 'block') {
          try { updateLegend(); } catch(e) {}
        }
      }

      let _countyShadeTimer = null;
      function scheduleCountyShading() {
        if (_countyShadeTimer) clearTimeout(_countyShadeTimer);
        _countyShadeTimer = setTimeout(() => { _countyShadeTimer = null; updateCountyShading(); }, 350);
      }

    const professionalsCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQn_GaXEpNjeKT8FV_Y_IiWzFGT7x_EZzYeX0tyb0QrplireviBXA-tIkc1k-MIQZIjPFj3C-q2Rqwh/pub?gid=275691108&single=true&output=csv";
    const blueTrianglesCsvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT0Yd4ZxmdQ5eO8A-cobQxyaiXdBrSj8m0E77CzmmCY5ZfkF6MObGtP8gCAlyTCoY5wyZFFUpOpEJvG/pub?gid=1764059716&single=true&output=csv";
    const zipCentroidUrl = "https://raw.githubusercontent.com/Link0923/Water_Treatment_Data/main/USA_Zip_Code_Centroid_Ref.json";

      async function loadData() {
        let professionalsFeatures = [];
        await Promise.all([
          (async () => { professionalsFeatures = await loadProfessionalsLayer(); })(),
          loadBlueTrianglesLayer()
        ]);
        if (countiesLayerRef && countiesLayerRef.visible) scheduleCountyShading();
        professionalsData = professionalsFeatures;
        try {
          if (manipulatorPane && getComputedStyle(manipulatorPane).display !== 'none') {
            renderFilterUI();
          }
        } catch (e) {}
      }
      
      

      async function loadProfessionalsLayer() {
        console.log("Fetching Professionals CSV data...");
        try {
          const response = await fetch(professionalsCsvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const csvText = await response.text();
          const jsonData = parseCSV(csvText);
          if (jsonData.length === 0) throw new Error("No data found in CSV");
          const features = parseExcelToFeatures(jsonData, 0);
          const headers = jsonData[0];
          await createProfessionalsLayer(features, headers);
          console.log("✅ Professionals CSV data loaded successfully!");
           return features;
        } catch (error) {
          console.error("❌ Failed to load Professionals CSV:", error);
          alert(`Failed to load Professionals data: ${error.message}`);
          return [];
        }
      }

      async function loadBlueTrianglesLayer() {
        console.log("Fetching Blue Triangles CSV data...");
        try {
          const response = await fetch(blueTrianglesCsvUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          const csvText = await response.text();
          const jsonData = parseCSV(csvText);
          if (jsonData.length === 0) throw new Error("No data found in CSV");
          if (!_zipCentroidIndexBuilt) {
            try { await buildZipCentroidIndex(); } catch(e){ console.warn('ZIP centroid index build failed (continuing):', e); }
          }
          const features = parseBlueTriangleFeatures(jsonData);
          const headers = jsonData[1] || jsonData[0];
          blueTrianglesData = features;
          await createBlueTrianglesLayer(features, headers);
          console.log("✅ Blue Triangles CSV data loaded successfully!");
          if (!features.length) {
            console.error('[BlueTriangles] 0 features created. Diagnostics follow:');
            console.error('  - Header rows scanned? See earlier [BlueTriangles] header log.');
            console.error('  - ZIP centroid index size:', _zipCentroidIndex ? Object.keys(_zipCentroidIndex).length : 0);
            console.error('  - If lat/long columns exist, verify they contain numeric values and are not all blank/0.');
            console.error('  - If only ZIPs are present, confirm ZIPs normalize to 5 digits and exist in centroid JSON.');
          }
        } catch (error) {
          console.error("❌ Failed to load Blue Triangles CSV:", error);
          alert(`Failed to load Blue Triangles data: ${error.message}`);
        }
      }
      function parseCSV(text) {
        const rows = [];
        let cur = '', inQuotes = false, row = [];
        for (let i = 0; i < text.length; i++) {
          const c = text[i];
          if (c === '"') {
            if (inQuotes && text[i+1] === '"') { cur += '"'; i++; }
            else inQuotes = !inQuotes;
          } else if (c === ',' && !inQuotes) {
            row.push(cur); cur = '';
          } else if ((c === '\n' || c === '\r') && !inQuotes) {
            if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
            cur = ''; row = [];
            if (c === '\r' && text[i+1] === '\n') i++;
          } else {
            cur += c;
          }
        }
        if (cur !== '' || row.length > 0) { row.push(cur); rows.push(row); }
        return rows.filter(r => r.length && r.some(cell => cell.trim() !== ''));
      }
      
      async function createProfessionalsLayer(features, headers) {
        const fields = [{ name: "ObjectID", type: "oid" }];
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const fieldName = header.toString().trim();
            let fieldType = "string";
            if (/^lat/i.test(fieldName) || /^lon/i.test(fieldName) || fieldName.toLowerCase().includes("latitude") || fieldName.toLowerCase().includes("longitude")) {
              fieldType = "double";
            } else if (fieldName.toLowerCase().includes("id") ||
                      fieldName.toLowerCase().includes("number") ||
                      fieldName.toLowerCase().includes("count")) {
              fieldType = "integer";
            }
            fields.push({ name: fieldName, type: fieldType });
          }
        });
        if (features.length) {
          const a0 = features[0].attributes || {};
          if (a0['Role_Category'] !== undefined && !fields.some(f => f.name === 'Role_Category')) {
            fields.push({ name: 'Role_Category', type: 'string' });
          }
          if (a0['Parent_Company'] !== undefined && !fields.some(f => f.name === 'Parent_Company')) {
            fields.push({ name: 'Parent_Company', type: 'string' });
          }
          if (a0['City'] !== undefined && !fields.some(f => f.name === 'City')) {
            fields.push({ name: 'City', type: 'string' });
          }
          if (a0['State'] !== undefined && !fields.some(f => f.name === 'State')) {
            fields.push({ name: 'State', type: 'string' });
          }
          if (a0['ZIP_Code'] !== undefined && !fields.some(f => f.name === 'ZIP_Code')) {
            fields.push({ name: 'ZIP_Code', type: 'string' });
          }
          if (a0['Country'] !== undefined && !fields.some(f => f.name === 'Country')) {
            fields.push({ name: 'Country', type: 'string' });
          }
          if (a0['State Abbr'] !== undefined && !fields.some(f => f.name === 'State Abbr')) {
            fields.push({ name: 'State Abbr', type: 'string' });
          }
          const expOrig = Object.keys(a0).find(k => k.toLowerCase() === 'years experience (numeric)' || k.toLowerCase() === 'years_experience_(numeric)' || k.toLowerCase().replace(/[^a-z0-9]/g,'') === 'yearsexperiencenumeric');
          if (expOrig && !fields.some(f => f.name === '_YearsExpNum')) {
            fields.push({ name: '_YearsExpNum', type: 'double' });
            features.forEach(f => {
              const raw = f.attributes[expOrig];
              let num = null;
              if (raw != null && raw !== '') {
                if (typeof raw === 'number') num = raw;
                else if (typeof raw === 'string') {
                  const cleaned = raw.replace(/[^0-9.\-]/g,'');
                  const parsed = parseFloat(cleaned);
                  if (!isNaN(parsed)) num = parsed; else num = null;
                }
              }
              f.attributes['_YearsExpNum'] = num;
            });
            console.log('[ExperienceField] Derived numeric field _YearsExpNum created');
          }
          console.log('[LocationFields] Availability first feature:', {
            City: a0['City'] !== undefined,
            State: a0['State'] !== undefined,
            ZIP_Code: a0['ZIP_Code'] !== undefined
          });
        }

        const roleColors = {
          "Construction, Installation, and Maintenance": "#FFA910",
          "Engineering & Technical Design or Advisor": "#FFFF01",
          "Field Service and Water Treatment": "#FF0000",
          "Finance and Accounting": "#DBFF78",
          "Leadership and management (non-Sales)": "#80B1D3",
          "Logistics, Delivery, and Warehousing": "#FDB462",
          "Manufacturing and Assembly": "#FFB2D3",
          "Other": "#E1E1E1",
          "Quality": "#4EEAD9",
          "Quality/Sampling/Laboratory": "#BC808D",
          "Sales and Account Management": "#4CE600",
          "Regulatory and EHS": "#F7F7F7",
          "Role Not Mapped": "#DE23D8",
          "Sylmar Group, SWT": "#030303",
        };

        let roleField = headers.find(h => h && (h.trim() === "Role_Category" || h.trim() === "Role Category"));
        if (!roleField) {
          roleField = headers.find(h => h && h.toString().replace(/[_ ]/g, '').toLowerCase().includes("rolecategory"));
        }
        if (features.length && features[0].attributes && features[0].attributes['Role_Category'] !== undefined) {
          roleField = 'Role_Category';
        }
        let renderer;
        if (roleField) {
          renderer = {
            type: "unique-value",
            field: roleField,
            uniqueValueInfos: Object.entries(roleColors).map(([role, color]) => ({
              value: role,
              symbol: {
                type: "simple-marker",
                color: color,
                size: "10px",
                outline: { color: "#000000", width: 2 }
              },
              label: role
            }))
          };
        } else {
          renderer = {
            type: "simple",
            symbol: {
              type: "simple-marker",
              color: "#FF6600",
              size: "10px",
              outline: { color: "#000000", width: 2 }
            }
          };
        }

        console.log(`Professionals features created: ${features.length}`);
        if (features.length === 0) {
          console.warn("No features created for professionals layer. Check latitude/longitude column names and data.");
        }

        const professionalsLayer = new FeatureLayer({
          source: features,
          title: "Water Treatment Professionals",
          objectIdField: "ObjectID",
          geometryType: "point",
          spatialReference: { wkid: 4326 },
          fields: fields,
          renderer: renderer,
          popupTemplate: {
            title: "Water Treatment Professional",
            content: createPopupContent(headers)
          },
          visible: true
        });
        map.add(professionalsLayer);
        professionalsLayerRef = professionalsLayer;
        if (features.length > 0) {
          professionalsLayer.when(() => {
            return professionalsLayer.queryExtent();
          }).then((response) => {
            view.goTo(response.extent.expand(1.2));
          });
        }
      }

      async function createBlueTrianglesLayer(features, headers) {
        const fields = [{ name: "ObjectID", type: "oid" }];
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const fieldName = header.toString().trim();
            let fieldType = "string";
            const lc = fieldName.toLowerCase();
            if (lc.includes("latitude") || lc === 'lat' || lc.includes("longitude") || lc === 'lon' || lc === 'long' || lc.includes('lng')) {
              fieldType = "double";
            } else if (/(^|_)(id|number|count)$/i.test(lc)) {
              fieldType = "integer";
            }
            fields.push({ name: fieldName, type: fieldType });
          }
        });
        const targetServiceLabel = 'Water treatment services? (Y/N)';
        waterCompanyServiceField = null;
        for (const h of headers) {
          if (!h) continue;
            const norm = h.toString().trim().toLowerCase();
            const normTarget = targetServiceLabel.toLowerCase();
            if (norm === normTarget) { waterCompanyServiceField = h.toString().trim(); break; }
            if (!waterCompanyServiceField && norm.replace(/\s*\(y\/n\)\s*/,'') === normTarget.replace(/\s*\(y\/n\)\s*/,'')) {
              waterCompanyServiceField = h.toString().trim();
            }
        }
        if (!waterCompanyServiceField) {
          const canonical = ['watertreatmentservicesyn','watertreatmentservices'];
          for (const h of headers) {
            if (!h) continue;
            const raw = h.toString().trim();
            const superNorm = raw.toLowerCase().replace(/[^a-z0-9]/g,'');
            if (canonical.includes(superNorm)) { waterCompanyServiceField = raw; break; }
            if (!waterCompanyServiceField && superNorm.startsWith('watertreatmentservices') && superNorm.endsWith('yn')) { waterCompanyServiceField = raw; break; }
          }
        }
        if (!waterCompanyServiceField && features && features.length) {
          const sampleCount = Math.min(50, features.length);
            const candidateScores = {};
            for (const h of headers) {
              if (!h) continue;
              const raw = h.toString().trim();
              let distinct = new Set();
              for (let i=0;i<sampleCount;i++) {
                const v = features[i].attributes[raw];
                if (v !== undefined && v !== null && v !== '') distinct.add(v.toString().trim());
              }
              if (distinct.size && [...distinct].every(v => /^(y|n|yes|no)$/i.test(v))) {
                candidateScores[raw] = distinct.size;
              }
            }
            const candidates = Object.entries(candidateScores).sort((a,b)=>a[1]-b[1]);
            if (candidates.length) {
              waterCompanyServiceField = candidates[0][0];
              console.warn('[WaterCompanySelection] Using heuristic match for service field:', waterCompanyServiceField, 'distinct sample values:', candidates[0][1]);
            }
        }
        console.log('[WaterCompanySelection] Blue Triangles headers (debug):', headers);
        console.log('[WaterCompanySelection] Detected service field:', waterCompanyServiceField || '(not found)');
        if (waterCompanyServiceField) {
          if (!fields.some(f => f.name === waterCompanyServiceAliasField)) {
            fields.push({ name: waterCompanyServiceAliasField, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let v = f.attributes[waterCompanyServiceField];
            let norm = (v == null ? '' : v.toString().trim().toUpperCase());
            if (norm === '1' || norm === 'TRUE') norm = 'Y';
            else if (norm === '0' || norm === 'FALSE') norm = 'N';
            else if (norm.startsWith('Y')) norm = 'Y';
            else if (norm.startsWith('N')) norm = 'N';
            else norm = '';
            f.attributes[waterCompanyServiceAliasField] = norm; 
          });
          console.log('[WaterCompanySelection] Alias field populated for service Y/N ->', waterCompanyServiceAliasField);
        }
        const hvacOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'hvac water treatment services');
        const hvacAlias = '_HVAC';
        if (hvacOriginalField) {
          if (!fields.some(f => f.name === hvacAlias)) {
            fields.push({ name: hvacAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[hvacOriginalField];
            if (raw == null) { f.attributes[hvacAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[hvacAlias] = norm;
          });
          console.log('[WaterCompanySelection] HVAC capability alias populated ->', hvacAlias, 'from', hvacOriginalField);
        } else {
          console.warn('[WaterCompanySelection] HVAC capability source field not found (expected: "HVAC water treatment services")');
        }
        const coolingOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'cooling water treatment services');
        const coolingAlias = '_COOLING';
        if (coolingOriginalField) {
          if (!fields.some(f => f.name === coolingAlias)) {
            fields.push({ name: coolingAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[coolingOriginalField];
            if (raw == null) { f.attributes[coolingAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[coolingAlias] = norm;
          });
          console.log('[WaterCompanySelection] Cooling capability alias populated ->', coolingAlias, 'from', coolingOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Cooling capability source field not found (expected: "Cooling Water Treatment services")');
        }
        const heatingOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'heating/boiler water treatment service');
        const heatingAlias = '_HEATING';
        if (heatingOriginalField) {
          if (!fields.some(f => f.name === heatingAlias)) {
            fields.push({ name: heatingAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[heatingOriginalField];
            if (raw == null) { f.attributes[heatingAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[heatingAlias] = norm;
          });
          console.log('[WaterCompanySelection] Heating capability alias populated ->', heatingAlias, 'from', heatingOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Heating capability source field not found (expected: "Heating/Boiler Water Treatment services")');
        }
        const filtrationOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'filtration/separation or reverse osmosis water treatment services');
        const filtrationAlias = '_FILTRATION';
        if (filtrationOriginalField) {
          if (!fields.some(f => f.name === filtrationAlias)) {
            fields.push({ name: filtrationAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[filtrationOriginalField];
            if (raw == null) { f.attributes[filtrationAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[filtrationAlias] = norm;
          });
          console.log('[WaterCompanySelection] Filtration capability alias populated ->', filtrationAlias, 'from', filtrationOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Filtration capability source field not found (expected: "Filtration/Separation or Reverse Osmosis water treatment services")');
        }
        const ultrapureOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'ultrapure water treatment');
        const ultrapureAlias = '_ULTRAPURE';
        if (ultrapureOriginalField) {
          if (!fields.some(f => f.name === ultrapureAlias)) {
            fields.push({ name: ultrapureAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[ultrapureOriginalField];
            if (raw == null) { f.attributes[ultrapureAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[ultrapureAlias] = norm;
          });
          console.log('[WaterCompanySelection] Ultrapure capability alias populated ->', ultrapureAlias, 'from', ultrapureOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Ultrapure capability source field not found (expected: "Ultrapure water treatment services")');
        }
        const wastewaterOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'wastewater treatment');
        const wastewaterAlias = '_WASTEWATER';
        if (wastewaterOriginalField) {
          if (!fields.some(f => f.name === wastewaterAlias)) {
            fields.push({ name: wastewaterAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[wastewaterOriginalField];
            if (raw == null) { f.attributes[wastewaterAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[wastewaterAlias] = norm;
          });
          console.log('[WaterCompanySelection] Wastewater capability alias populated ->', wastewaterAlias, 'from', wastewaterOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Wastewater capability source field not found (expected: "Wastewater treatment services")');
        }
        const glycolOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'glycol');
        const glycolAlias = '_GLYCOL';
        if (glycolOriginalField) {
          if (!fields.some(f => f.name === glycolAlias)) {
            fields.push({ name: glycolAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[wastewaterOriginalField];
            if (raw == null) { f.attributes[wastewaterAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[wastewaterAlias] = norm;
          });
          console.log('[WaterCompanySelection] Wastewater capability alias populated ->', wastewaterAlias, 'from', wastewaterOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Wastewater capability source field not found (expected: "Wastewater treatment services")');
        }
        const cleaningOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'cleaning / sanitization / disinfection');
        const cleaningAlias = '_CLEANING';
        if (cleaningOriginalField) {
          if (!fields.some(f => f.name === cleaningAlias)) {
            fields.push({ name: cleaningAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[cleaningOriginalField];
            if (raw == null) { f.attributes[cleaningAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[cleaningAlias] = norm;
          });
          console.log('[WaterCompanySelection] Cleaning capability alias populated ->', cleaningAlias, 'from', cleaningOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Cleaning capability source field not found (expected: "Cleaning / Sanitization / Disinfection services")');
        }
        const legionellaOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'legionella or other regulatory testing');
        const legionellaAlias = '_LEGIONELLA';
        if (legionellaOriginalField) {
          if (!fields.some(f => f.name === legionellaAlias)) {
            fields.push({ name: legionellaAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[legionellaOriginalField];
            if (raw == null) { f.attributes[legionellaAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[legionellaAlias] = norm;
          });
          console.log('[WaterCompanySelection] Legionella capability alias populated ->', legionellaAlias, 'from', legionellaOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Legionella capability source field not found (expected: "Legionella or other regulatory testing")');
        }
        const chemicalBlendingOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'chemical blending, specialty formulation, private label for water treatment');
        const chemicalBlendingAlias = '_CHEMICALBLENDING';
        if (chemicalBlendingOriginalField) {
          if (!fields.some(f => f.name === chemicalBlendingAlias)) {
            fields.push({ name: chemicalBlendingAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[chemicalBlendingOriginalField];
            if (raw == null) { f.attributes[chemicalBlendingAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[chemicalBlendingAlias] = norm;
          });
          console.log('[WaterCompanySelection] Chemical Blending capability alias populated ->', chemicalBlendingAlias, 'from', chemicalBlendingOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Chemical Blending capability source field not found (expected: "Chemical Blending, specialty formulation, private label for water treatment")');
        }
        const manufacturingOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'manufacturing or assembly: pumps / controls / sensors');
        const manufacturingAlias = '_MANUFACTURING';
        if (manufacturingOriginalField) {
          if (!fields.some(f => f.name === manufacturingAlias)) {
            fields.push({ name: manufacturingAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[manufacturingOriginalField];
            if (raw == null) { f.attributes[manufacturingAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[manufacturingAlias] = norm;
          });
          console.log('[WaterCompanySelection] Manufacturing capability alias populated ->', manufacturingAlias, 'from', manufacturingOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Manufacturing capability source field not found (expected: "Manufacturing or assembly: Pumps / Controls / sensors")');
        }
        const installationOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'installation and/or maintenance: pumps / controls / sensors');
        const installationAlias = '_INSTALLATION';
        if (installationOriginalField) {
          if (!fields.some(f => f.name === installationAlias)) {
            fields.push({ name: installationAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[installationOriginalField];
            if (raw == null) { f.attributes[installationAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[installationAlias] = norm;
          });
          console.log('[WaterCompanySelection] Installation capability alias populated ->', installationAlias, 'from', installationOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Installation capability source field not found (expected: "Installation and/or maintenance: Pumps / Controls / sensors")');
        }
        const manufacturing1OriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'manufacturing or assembly: water treatment equipment - filters, membrane systems, reverse osmosis (ro), softeners, chlorine or ozone generators');
        const manufacturing1Alias = '_MANUFACTURING1';
        if (manufacturing1OriginalField) {
          if (!fields.some(f => f.name === manufacturing1Alias)) {
            fields.push({ name: manufacturing1Alias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[manufacturing1OriginalField];
            if (raw == null) { f.attributes[manufacturing1Alias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[manufacturing1Alias] = norm;
          });
          console.log('[WaterCompanySelection] Manufacturing 1 capability alias populated ->', manufacturing1Alias, 'from', manufacturing1OriginalField);
        } else {
          console.warn('[WaterCompanySelection] Manufacturing 1 capability source field not found (expected: "Manufacturing or assembly: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators")');
        }
        const installation1OriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'installation and/or maintenance: water treatment equipment - filters, membrane systems, reverse osmosis (ro), softeners, chlorine or ozone generators');
        const installation1Alias = '_INSTALLATION1';
        if (installation1OriginalField) {
          if (!fields.some(f => f.name === installation1Alias)) {
            fields.push({ name: installation1Alias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[installation1OriginalField];
            if (raw == null) { f.attributes[installation1Alias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[installation1Alias] = norm;
          });
          console.log('[WaterCompanySelection] Installation 1 capability alias populated ->', installation1Alias, 'from', installation1OriginalField);
        } else {
          console.warn('[WaterCompanySelection] Installation 1 capability source field not found (expected: "Installation and/or maintenance: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators")');
        }
        const commercialOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'commercial / office / apartment / warehouse facilities - general');
        const commercialAlias = '_COMMERCIAL';
        if (commercialOriginalField) {
          if (!fields.some(f => f.name === commercialAlias)) {
            fields.push({ name: commercialAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[commercialOriginalField];
            if (raw == null) { f.attributes[commercialAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[commercialAlias] = norm;
          });
          console.log('[WaterCompanySelection] Commercial capability alias populated ->', commercialAlias, 'from', commercialOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Commercial capability source field not found (expected: "Commercial / office / apartment / warehouse facilities - general")');
        }
        const hospitalityOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'hospitality, e.g., hotels and restaurants');
        const hospitalityAlias = '_HOSPITALITY';
        if (hospitalityOriginalField) {
          if (!fields.some(f => f.name === hospitalityAlias)) {
            fields.push({ name: hospitalityAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[hospitalityOriginalField];
            if (raw == null) { f.attributes[hospitalityAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[hospitalityAlias] = norm;
          });
          console.log('[WaterCompanySelection] Hospitality capability alias populated ->', hospitalityAlias, 'from', hospitalityOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Hospitality capability source field not found (expected: "Hospitality, e.g., hotels and restaurants")');
        }
        const healthcareOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'healthcare / hospitals');
        const healthcareAlias = '_HEALTHCARE';
        if (healthcareOriginalField) {
          if (!fields.some(f => f.name === healthcareAlias)) {
            fields.push({ name: healthcareAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[healthcareOriginalField];
            if (raw == null) { f.attributes[healthcareAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[healthcareAlias] = norm;
          });
          console.log('[WaterCompanySelection] Healthcare capability alias populated ->', healthcareAlias, 'from', healthcareOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Healthcare capability source field not found (expected: "Healthcare / hospitals")');
        }
        const educationOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'education / schools + universities');
        const educationAlias = '_EDUCATION';
        if (educationOriginalField) {
          if (!fields.some(f => f.name === educationAlias)) {
            fields.push({ name: educationAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[educationOriginalField];
            if (raw == null) { f.attributes[educationAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[educationAlias] = norm;
          });
          console.log('[WaterCompanySelection] Education capability alias populated ->', educationAlias, 'from', educationOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Education capability source field not found (expected: "Education / schools + universities")');
        }
        const governmentOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'government facilities');
        const governmentAlias = '_GOVERNMENT';
        if (governmentOriginalField) {
          if (!fields.some(f => f.name === governmentAlias)) {
            fields.push({ name: governmentAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[governmentOriginalField];
            if (raw == null) { f.attributes[governmentAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[governmentAlias] = norm;
          });
          console.log('[WaterCompanySelection] Government capability alias populated ->', governmentAlias, 'from', governmentOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Government capability source field not found (expected: "Government facilities")');
        }
        const industrialOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'industrial or manufacturing facilities - general');
        const industrialAlias = '_INDUSTRIAL';
        if (industrialOriginalField) {
          if (!fields.some(f => f.name === industrialAlias)) {
            fields.push({ name: industrialAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[industrialOriginalField];
            if (raw == null) { f.attributes[industrialAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[industrialAlias] = norm;
          });
          console.log('[WaterCompanySelection] Industrial capability alias populated ->', industrialAlias, 'from', industrialOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Industrial capability source field not found (expected: "Industrial or manufacturing facilities - general")');
        }
        const pharmaceuticalOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'pharmaceutical manufacturing');
        const pharmaceuticalAlias = '_PHARMACEUTICAL';
        if (pharmaceuticalOriginalField) {
          if (!fields.some(f => f.name === pharmaceuticalAlias)) {
            fields.push({ name: pharmaceuticalAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[pharmaceuticalOriginalField];
            if (raw == null) { f.attributes[pharmaceuticalAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[pharmaceuticalAlias] = norm;
          });
          console.log('[WaterCompanySelection] Pharmaceutical capability alias populated ->', pharmaceuticalAlias, 'from', pharmaceuticalOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Pharmaceutical capability source field not found (expected: "Pharmaceutical manufacturing")');
        }
        const dataCentersOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'data centers');
        const dataCentersAlias = '_DATA_CENTERS';
        if (dataCentersOriginalField) {
          if (!fields.some(f => f.name === dataCentersAlias)) {
            fields.push({ name: dataCentersAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[dataCentersOriginalField];
            if (raw == null) { f.attributes[dataCentersAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[dataCentersAlias] = norm;
          });
          console.log('[WaterCompanySelection] Data centers capability alias populated ->', dataCentersAlias, 'from', dataCentersOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Data centers capability source field not found (expected: "Data centers")');
        }
        const foodBeverageOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'food and/or beverage processing + manufacture');
        const foodBeverageAlias = '_FOOD_BEVERAGE';
        if (foodBeverageOriginalField) {
          if (!fields.some(f => f.name === foodBeverageAlias)) {
            fields.push({ name: foodBeverageAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[foodBeverageOriginalField];
            if (raw == null) { f.attributes[foodBeverageAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[foodBeverageAlias] = norm;
          });
          console.log('[WaterCompanySelection] Food and/or beverage processing + manufacture capability alias populated ->', foodBeverageAlias, 'from', foodBeverageOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Food and/or beverage processing + manufacture capability source field not found (expected: "Food and/or beverage processing + manufacture")');
        }
        const agricultureOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'agriculture - general');
        const agricultureAlias = '_AGRICULTURE';
        if (agricultureOriginalField) {
          if (!fields.some(f => f.name === agricultureAlias)) {
            fields.push({ name: agricultureAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[agricultureOriginalField];
            if (raw == null) { f.attributes[agricultureAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[agricultureAlias] = norm;
          });
          console.log('[WaterCompanySelection] Agriculture - general capability alias populated ->', agricultureAlias, 'from', agricultureOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Agriculture - general capability source field not found (expected: "Agriculture - general")');
        }
        const agriculture1OriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'agriculture - irrigation, crops');
        const agriculture1Alias = '_AGRICULTURE1';
        if (agriculture1OriginalField) {
          if (!fields.some(f => f.name === agriculture1Alias)) {
            fields.push({ name: agriculture1Alias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[agriculture1OriginalField];
            if (raw == null) { f.attributes[agriculture1Alias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[agriculture1Alias] = norm;
          });
          console.log('[WaterCompanySelection] Agriculture - irrigation, crops capability alias populated ->', agriculture1Alias, 'from', agriculture1OriginalField);
        } else {
          console.warn('[WaterCompanySelection] Agriculture - irrigation, crops capability source field not found (expected: "Agriculture - irrigation, crops")');
        }
        const agriculture2OriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'agriculture - livestock / aquaculture');
        const agriculture2Alias = '_AGRICULTURE2';
        if (agriculture2OriginalField) {
          if (!fields.some(f => f.name === agriculture2Alias)) {
            fields.push({ name: agriculture2Alias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[agriculture2OriginalField];
            if (raw == null) { f.attributes[agriculture2Alias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[agriculture2Alias] = norm;
          });
          console.log('[WaterCompanySelection] Agriculture - livestock / aquaculture capability alias populated ->', agriculture2Alias, 'from', agriculture2OriginalField);
        } else {
          console.warn('[WaterCompanySelection] Agriculture - livestock / aquaculture capability source field not found (expected: "Agriculture - livestock / aquaculture")');
        }
        const municipalOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'municipal / public drinking water');
        const municipalAlias = '_MUNICIPAL';
        if (municipalOriginalField) {
          if (!fields.some(f => f.name === municipalAlias)) {
            fields.push({ name: municipalAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[municipalOriginalField];
            if (raw == null) { f.attributes[municipalAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[municipalAlias] = norm;
          });
          console.log('[WaterCompanySelection] Municipal / Public drinking water capability alias populated ->', municipalAlias, 'from', municipalOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Municipal / Public drinking water capability source field not found (expected: "Municipal / Public drinking water")');
        }
        const municipal1OriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'municipal / public wastewater');
        const municipal1Alias = '_MUNICIPAL1';
        if (municipal1OriginalField) {
          if (!fields.some(f => f.name === municipal1Alias)) {
            fields.push({ name: municipal1Alias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[municipal1OriginalField];
            if (raw == null) { f.attributes[municipal1Alias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[municipal1Alias] = norm;
          });
          console.log('[WaterCompanySelection] Municipal / Public wastewater capability alias populated ->', municipal1Alias, 'from', municipal1OriginalField);
        } else {
          console.warn('[WaterCompanySelection] Municipal / Public wastewater capability source field not found (expected: "Municipal / Public wastewater")');
        }
        const plumbingOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'plumbing / hvac contractors');
        const plumbingAlias = '_PLUMBING';
        if (plumbingOriginalField) {
          if (!fields.some(f => f.name === plumbingAlias)) {
            fields.push({ name: plumbingAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[plumbingOriginalField];
            if (raw == null) { f.attributes[plumbingAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[plumbingAlias] = norm;
          });
          console.log('[WaterCompanySelection] Plumbing / HVAC contractors capability alias populated ->', plumbingAlias, 'from', plumbingOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Plumbing / HVAC contractors capability source field not found (expected: "Plumbing / HVAC contractors")');
        }
        const domesticOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'domestic / non-commercial residential');
        const domesticAlias = '_DOMESTIC';
        if (domesticOriginalField) {
          if (!fields.some(f => f.name === domesticAlias)) {
            fields.push({ name: domesticAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[domesticOriginalField];
            if (raw == null) { f.attributes[domesticAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[domesticAlias] = norm;
          });
          console.log('[WaterCompanySelection] Domestic / non-commercial residential capability alias populated ->', domesticAlias, 'from', domesticOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Domestic / non-commercial residential capability source field not found (expected: "Domestic / non-commercial residential")');
        }
        const labOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'lab services');
        const labAlias = '_LAB';
        if (labOriginalField) {
          if (!fields.some(f => f.name === labAlias)) {
            fields.push({ name: labAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[labOriginalField];
            if (raw == null) { f.attributes[labAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[labAlias] = norm;
          });
          console.log('[WaterCompanySelection] Lab services capability alias populated ->', labAlias, 'from', labOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Lab services capability source field not found (expected: "Lab services")');
        }
        const engineeringOriginalField = headers.find(h => h && h.toString().trim().toLowerCase() === 'engineering design');
        const engineeringAlias = '_ENGINEERING';
        if (engineeringOriginalField) {
          if (!fields.some(f => f.name === engineeringAlias)) {
            fields.push({ name: engineeringAlias, type: 'string' });
          }
          features.forEach(f => {
            if (!f.attributes) return;
            let raw = f.attributes[engineeringOriginalField];
            if (raw == null) { f.attributes[engineeringAlias] = ''; return; }
            let norm = raw.toString().trim();
            if (norm === '1') norm = '1'; else norm = '';
            f.attributes[engineeringAlias] = norm;
          });
          console.log('[WaterCompanySelection] Engineering design capability alias populated ->', engineeringAlias, 'from', engineeringOriginalField);
        } else {
          console.warn('[WaterCompanySelection] Engineering design capability source field not found (expected: "Engineering design")');
        }

        const renderer = {
          type: "simple",
          symbol: {
            type: "simple-marker",
            style: "triangle",
            color: "#0074D9", 
            size: "14px",
            outline: { color: "#003366", width: 2 }
          }
        };

        const blueTrianglesLayer = new FeatureLayer({
          source: features,
          title: "Blue Triangle Points",
          objectIdField: "ObjectID",
          geometryType: "point",
          spatialReference: { wkid: 4326 },
          fields: fields,
          renderer: renderer,
          popupTemplate: {
            title: "Point Info",
            content: createPopupContent(headers)
          },
          visible: false
        });
        blueTrianglesLayerRef = blueTrianglesLayer;
        map.add(blueTrianglesLayer);
      }

      function parseExcelToFeatures(jsonData, headerRowIndex = 0) {
        if (jsonData.length <= headerRowIndex) return [];
        const headers = jsonData[headerRowIndex].map(h => h ? h.toString().trim() : '');
        console.log('[Parser] Using row', headerRowIndex, 'as headers:', headers);
        const features = [];
        const latIndex = findColumnIndex(headers, ['latitude', 'lat', 'zip_latitude', 'Lat']);
        const lonIndex = findColumnIndex(headers, ['longitude', 'lon', 'lng', 'zip_longitude', 'Long']);
  const fipsIndex = findColumnIndex(headers, ['FIPS_5Digit','5_digit_FIPS_Code', 'FIPS', 'FIPS_Code', 'fips']);
        // Potential ZIP Code fallback column(s)
        const zipIdxPrimary = findColumnIndex(headers, ['zip code','zip_code','zipcode','zip','postal']);
        const cityIdx = findColumnIndex(headers, ['city','City','town']);
        const stateIdx = findColumnIndex(headers, ['state','State','st']);
        console.log("Headers found:", headers);
        console.log(`Latitude column: ${headers[latIndex]} (index: ${latIndex})`);
        console.log(`Longitude column: ${headers[lonIndex]} (index: ${lonIndex})`);
        let missingLatLonCount = 0, zipFallbackUsed = 0, zipFallbackUnmatched = 0;
        for (let i = headerRowIndex + 1; i < jsonData.length; i++) {
          const row = jsonData[i];
          const attributes = { ObjectID: i };
          headers.forEach((header, index) => {
            if (header) {
              let v = row[index];
              if (typeof v === 'string') v = v.trim();
              attributes[header] = v == null ? '' : v;
            }
          });
          if (attributes['Role_Category'] === undefined && attributes['Role Category'] !== undefined) {
            attributes['Role_Category'] = attributes['Role Category'];
          }
          if (attributes['Parent_Company'] === undefined && attributes['Parent Company'] !== undefined) {
            attributes['Parent_Company'] = attributes['Parent Company'];
          }
          if (cityIdx !== -1) {
            const cv = row[cityIdx];
            if (attributes['City'] === undefined) attributes['City'] = (cv == null ? '' : cv);
          }
          if (stateIdx !== -1) {
            const sv = row[stateIdx];
            if (attributes['State'] === undefined) attributes['State'] = (sv == null ? '' : sv);
          }
          if (zipIdxPrimary !== -1) {
            const zv = row[zipIdxPrimary];
            if (attributes['ZIP_Code'] === undefined && zv != null && zv.toString().trim() !== '') {
              attributes['ZIP_Code'] = zv.toString().trim();
            }
          }
          if ((!attributes['City'] || !attributes['State']) && (attributes['Location'] || attributes['location'])) {
            const locRaw = attributes['Location'] || attributes['location'];
            if (locRaw && typeof locRaw === 'string') {
              const parts = locRaw.split(',').map(p => p.trim()).filter(p => p);
              if (parts.length >= 3) {
                if (!attributes['City']) attributes['City'] = parts[0];
                if (!attributes['State']) attributes['State'] = parts[1];
                if (!attributes['Country']) attributes['Country'] = parts[2];
              } else if (parts.length === 2) {
                if (!attributes['City']) attributes['City'] = parts[0];
                if (!attributes['State']) attributes['State'] = parts[1];
              }
            }
          }
          if (attributes['State'] && !attributes['State Abbr']) {
            const stateMap = window.__STATE_ABBR_MAP || (window.__STATE_ABBR_MAP = {
              'alabama':'AL','alaska':'AK','arizona':'AZ','arkansas':'AR','california':'CA','colorado':'CO','connecticut':'CT','delaware':'DE','district of columbia':'DC','florida':'FL','georgia':'GA','hawaii':'HI','idaho':'ID','illinois':'IL','indiana':'IN','iowa':'IA','kansas':'KS','kentucky':'KY','louisiana':'LA','maine':'ME','maryland':'MD','massachusetts':'MA','michigan':'MI','minnesota':'MN','mississippi':'MS','missouri':'MO','montana':'MT','nebraska':'NE','nevada':'NV','new hampshire':'NH','new jersey':'NJ','new mexico':'NM','new york':'NY','north carolina':'NC','north dakota':'ND','ohio':'OH','oklahoma':'OK','oregon':'OR','pennsylvania':'PA','rhode island':'RI','south carolina':'SC','south dakota':'SD','tennessee':'TN','texas':'TX','utah':'UT','vermont':'VT','virginia':'VA','washington':'WA','west virginia':'WV','wisconsin':'WI','wyoming':'WY' });
            const stLower = attributes['State'].toString().trim().toLowerCase();
            if (stateMap[stLower]) attributes['State Abbr'] = stateMap[stLower];
          }
          if (fipsIndex !== -1) {
            let fv = row[fipsIndex];
            if (typeof fv === 'string') fv = fv.trim();
            const headerName = headers[fipsIndex];
            if (headerName && headerName.toLowerCase().includes('fips_5digit')) {
              attributes['FIPS_5Digit'] = fv == null ? '' : fv;
            }
            attributes['FIPS'] = fv == null ? '' : fv; 
          }
          let geometry = null;
          if (latIndex !== -1 && lonIndex !== -1) {
            const lat = parseFloat(row[latIndex]);
            const lon = parseFloat(row[lonIndex]);
            if (!isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0) {
              geometry = { type: 'point', longitude: lon, latitude: lat };
            } else {
              missingLatLonCount++;
            }
          } else {
            missingLatLonCount++;
          }
          if (!geometry && zipIdxPrimary !== -1) {
            let rawZip = row[zipIdxPrimary];
            if (rawZip != null && rawZip.toString().trim() !== '') {
              let zipNorm = rawZip.toString().trim().replace(/[^0-9]/g,'');
              if (zipNorm.length >= 9) zipNorm = zipNorm.substring(0,5);
              if (zipNorm.length === 4) zipNorm = '0'+zipNorm; else if (zipNorm.length === 3) zipNorm = '00'+zipNorm;
              if (zipNorm.length === 5 && _zipCentroidIndexBuilt && _zipCentroidIndex && _zipCentroidIndex[zipNorm]) {
                const c = _zipCentroidIndex[zipNorm];
                geometry = { type: 'point', longitude: c.x, latitude: c.y };
                zipFallbackUsed++;
                attributes['ZIP_Normalized'] = zipNorm;
              } else {
                zipFallbackUnmatched++;
              }
            }
          }
          if (geometry) {
            features.push({ geometry, attributes });
          }
          else {
          }
        }
        console.log(`[Professionals] ZIP fallback summary: missingLatLonRows=${missingLatLonCount}, zipFallbackUsed=${zipFallbackUsed}, zipFallbackUnmatched=${zipFallbackUnmatched}`);
        if (!features.length) {
          console.warn('[Professionals] No features created even after ZIP fallback.');
        }
        return features;
      }
      function parseBlueTriangleFeatures(jsonData) {
        if (jsonData.length < 2) return [];
        const maxHeaderScan = Math.min(8, jsonData.length - 1);
        const normalizeRow = row => row.map(h => h ? h.toString().trim() : '');
        const scoreHeader = cells => {
          const lc = cells.map(c => c.toLowerCase());
          let s = 0;
          lc.forEach(c => {
            if (/^lat$|latitude/.test(c)) s += 3;
            if (/^lon$|^long$|longitude|lng/.test(c)) s += 3;
            if (/zip/.test(c)) s += 2;
            if (/postal/.test(c)) s += 2;
          });
          return s;
        };
        let headerRowIndex = 0, bestScore = -1, headers = [];
        for (let r = 0; r <= maxHeaderScan; r++) {
          const candidate = normalizeRow(jsonData[r]);
            const sc = scoreHeader(candidate);
            if (sc > bestScore) { bestScore = sc; headerRowIndex = r; headers = candidate; }
        }
        if (headerRowIndex !== 0) {
          console.warn(`[BlueTriangles] Auto-selected row ${headerRowIndex} as header (score=${bestScore}).`);
        } else {
          console.log(`[BlueTriangles] Using row 0 as header (score=${bestScore}).`);
        }
        const features = [];
        function strictIndex(headersArr, candidates) {
          const lowered = headersArr.map(h => h ? h.toLowerCase().trim() : '');
            for (let i=0;i<lowered.length;i++) {
              const val = lowered[i];
              if (candidates.includes(val)) return i;
            }
            return -1;
        }
        const latIndex = strictIndex(headers, ['lat','latitude']);
        const lonIndex = strictIndex(headers, ['lon','long','longitude','lng']);
        let zipIndex = findColumnIndex(headers, ['zip','zip_code','zipcode','postal','zip code','zip-code']);
        if (zipIndex === -1) {
          for (let i=0;i<headers.length;i++) {
            const h = headers[i];
            if (h && /zip/i.test(h) && !/lat|long|lng/i.test(h)) { zipIndex = i; break; }
          }
        }
        console.log('Headers (BlueTriangles) row', headerRowIndex, headers);
        console.log('Detected columns latIndex', latIndex, 'lonIndex', lonIndex, 'zipIndex', zipIndex);
        if (latIndex === -1 || lonIndex === -1) {
          if (zipIndex === -1) {
            throw new Error('Blue Triangles: no Lat/Long or ZIP column found. Headers used: ' + headers.join(', '));
          } else if (!_zipCentroidIndexBuilt) {
            console.warn('Lat/Long absent; ZIP present but centroid index not yet built. Some points may be skipped.');
          }
        }
        const indexSize = _zipCentroidIndex ? Object.keys(_zipCentroidIndex).length : 0;
        if (!_zipCentroidIndexBuilt) {
          console.log('[BlueTriangles] ZIP centroid index not built yet at parse time.');
        } else {
          console.log(`[BlueTriangles] ZIP centroid index size: ${indexSize}`);
        }
        let missingZipCount = 0, unmatchedZipCount = 0, zipGeomAssigned = 0;
        let latLongGeomAssigned = 0;
        const unmatchedSamples = new Set();
        const sampleRawZips = [];
        let oid = 1;
        for (let r = headerRowIndex + 1; r < jsonData.length; r++) {
          const row = jsonData[r];
          if (!row || !row.length || row.every(c => !c || c.toString().trim()==='')) continue; 
          const attributes = { ObjectID: oid++ };
          headers.forEach((h, idx) => {
            if (h) {
              let v = row[idx];
              if (typeof v === 'string') v = v.trim();
              attributes[h] = v == null ? '' : v;
            }
          });
          let geometry = null;
          if (latIndex !== -1 && lonIndex !== -1) {
            const lat = parseFloat(row[latIndex]);
            const lon = parseFloat(row[lonIndex]);
            if (!isNaN(lat) && !isNaN(lon) && lat !== 0 && lon !== 0) {
              geometry = { type: 'point', longitude: lon, latitude: lat };
              latLongGeomAssigned++;
            }
          }
          if (!geometry && zipIndex !== -1) {
            let zipRaw = row[zipIndex];
            if (zipRaw == null || zipRaw.toString().trim() === '') {
              missingZipCount++;
            } else {
              let zip = zipRaw.toString().trim();
              if (sampleRawZips.length < 15) sampleRawZips.push(zipRaw);
              zip = zip.replace(/[^0-9]/g,'');
              if (zip.length >= 9) zip = zip.substring(0,5); // ZIP+4 -> base
              if (zip.length === 3) zip = '00'+zip; else if (zip.length === 4) zip = '0'+zip;
              if (_zipCentroidIndex && _zipCentroidIndex[zip]) {
                const c = _zipCentroidIndex[zip];
                geometry = { type: 'point', longitude: c.x, latitude: c.y };
                zipGeomAssigned++;
              } else {
                unmatchedZipCount++;
                if (unmatchedSamples.size < 25) unmatchedSamples.add(zip);
              }
              attributes['ZIP_Normalized'] = zip;
            }
          }
          if (geometry) features.push({ geometry, attributes });
        }
        console.log(`Blue Triangles parse summary: headerRow=${headerRowIndex}, rawRows=${jsonData.length - (headerRowIndex+1)}, features=${features.length}, latLongGeom=${latLongGeomAssigned}, zipGeom=${zipGeomAssigned}, missingZip=${missingZipCount}, unmatchedZip=${unmatchedZipCount}`);
        if (sampleRawZips.length) {
          console.log('[BlueTriangles] Sample raw ZIP values (first up to 15):', sampleRawZips.join(', '));
        }
        if (unmatchedSamples.size) {
          console.warn('Sample unmatched ZIPs:', Array.from(unmatchedSamples).join(', '));
        }
        return features;
      }
      let _zipCentroidIndex = null;
      let _zipCentroidIndexBuilt = false;
      async function buildZipCentroidIndex() {
        if (_zipCentroidIndexBuilt) return _zipCentroidIndex;
        try {
          console.time('[ZIP] static centroid fetch');
          const resp = await fetch(zipCentroidUrl, { cache: 'no-store' });
          if (!resp.ok) throw new Error('HTTP ' + resp.status + ' ' + resp.statusText);
          const raw = await resp.json();
          const index = {};
          let added = 0;
          function normalizeZip(z) {
            if (!z) return null;
            z = String(z).trim().replace(/[^0-9]/g,'');
            if (z.length === 3) z = '00'+z; else if (z.length === 4) z = '0'+z;
            if (z.length !== 5) return null;
            return z;
          }
          function addPair(zip, lon, lat) {
            const z = normalizeZip(zip);
            if (!z) return;
            const x = parseFloat(lon);
            const y = parseFloat(lat);
            if (isNaN(x) || isNaN(y)) return;
            if (index[z] == null) { index[z] = { x, y }; added++; }
          }
          const isPlainObject = raw && typeof raw === 'object' && !Array.isArray(raw);
          const rawType = Array.isArray(raw) ? 'array' : (raw ? typeof raw : 'null');
          console.log('[ZIP] Raw centroid JSON type:', rawType);
          if (isPlainObject) {
            const firstKeys = Object.keys(raw).slice(0,5);
            console.log('[ZIP] First object keys:', firstKeys.join(', '));
          } else if (Array.isArray(raw)) {
            console.log('[ZIP] Array length:', raw.length);
            if (raw.length && typeof raw[0] === 'object') {
              console.log('[ZIP] First array element keys:', Object.keys(raw[0]).join(', '));
            }
          }

          if (isPlainObject && Object.keys(raw).length && Array.isArray(raw[Object.keys(raw)[0]])) {
            for (const key in raw) {
              if (!Object.prototype.hasOwnProperty.call(raw, key)) continue;
              const val = raw[key];
              if (Array.isArray(val) && val.length === 2) addPair(key, val[0], val[1]);
            }
          } else if (isPlainObject && Object.keys(raw).length && typeof raw[Object.keys(raw)[0]] === 'object' && !Array.isArray(raw[Object.keys(raw)[0]])) {
            for (const key in raw) {
              if (!Object.prototype.hasOwnProperty.call(raw,key)) continue;
              const val = raw[key];
              if (!val || typeof val !== 'object') continue;
              const lon = val.lon ?? val.longitude ?? val.x ?? val.Lon ?? val.Longitude ?? val.X;
              const lat = val.lat ?? val.latitude ?? val.y ?? val.Lat ?? val.Latitude ?? val.Y;
              addPair(key, lon, lat);
            }
          } else if (isPlainObject && Array.isArray(raw.features) && raw.geometryType === 'esriGeometryPoint') {
            console.log('[ZIP] Detected Esri FeatureSet structure. Parsing features array length:', raw.features.length);
            function mercatorToLonLat(x, y) {
              const R = 6378137;
              const lon = (x / R) * 180 / Math.PI;
              const lat = (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2) * 180 / Math.PI;
              return [lon, lat];
            }
            raw.features.forEach(f => {
              if (!f || !f.attributes) return;
              const attrs = f.attributes;
              const zipKey = attrs.ZIP_CODE || attrs.zip || attrs['Zip Code'] || attrs['ZIP Code'];
              let lon = attrs.Longitude != null ? attrs.Longitude : null;
              let lat = attrs.Latitude != null ? attrs.Latitude : null;
              if ((lon == null || lat == null) && f.geometry && typeof f.geometry.x === 'number' && typeof f.geometry.y === 'number') {
                const ll = mercatorToLonLat(f.geometry.x, f.geometry.y);
                lon = lon == null ? ll[0] : lon;
                lat = lat == null ? ll[1] : lat;
              }
              addPair(zipKey, lon, lat);
            });
          } else if (Array.isArray(raw)) {
            raw.forEach(obj => {
              if (!obj) return;
              if (Array.isArray(obj)) { if (obj.length>=3) addPair(obj[0], obj[1], obj[2]); return; }
              if (typeof obj !== 'object') return;
              const zipKey = obj.ZIP_CODE || obj.zip || obj.Zip || obj.ZIP || obj.postal || obj.Postal || obj['Zip Code'] || obj['ZIP Code'];
              const lon = obj.lon ?? obj.longitude ?? obj.x ?? obj.Lon ?? obj.Longitude ?? obj.X;
              const lat = obj.lat ?? obj.latitude ?? obj.y ?? obj.Lat ?? obj.Latitude ?? obj.Y;
              addPair(zipKey, lon, lat);
            });
          } else if (raw && raw.type === 'FeatureCollection' && Array.isArray(raw.features)) {
            raw.features.forEach(f => {
              if (!f || f.type !== 'Feature') return;
              const props = f.properties || {};
              const zipKey = props.ZIP_CODE || props.zip || props.ZIP || props.Postal || props.postal || props['Zip Code'] || props['ZIP Code'];
              if (f.geometry && f.geometry.type === 'Point' && Array.isArray(f.geometry.coordinates)) {
                const [lon, lat] = f.geometry.coordinates;
                addPair(zipKey, lon, lat);
              }
            });
          } else if (isPlainObject && raw && raw.data) {
            const d = raw.data;
            if (Array.isArray(d)) {
              d.forEach(obj => {
                if (!obj) return;
                if (Array.isArray(obj)) { if (obj.length>=3) addPair(obj[0],obj[1],obj[2]); return; }
                if (typeof obj !== 'object') return;
                const zipKey = obj.ZIP_CODE || obj.zip || obj.Zip || obj.ZIP || obj.postal || obj.Postal || obj['Zip Code'] || obj['ZIP Code'];
                const lon = obj.lon ?? obj.longitude ?? obj.x ?? obj.Lon ?? obj.Longitude ?? obj.X;
                const lat = obj.lat ?? obj.latitude ?? obj.y ?? obj.Lat ?? obj.Latitude ?? obj.Y;
                addPair(zipKey, lon, lat);
              });
            }
          } else {
            console.warn('[ZIP] Unrecognized centroid JSON structure; no entries parsed.');
          }
          console.timeEnd('[ZIP] static centroid fetch');
          _zipCentroidIndex = index;
          _zipCentroidIndexBuilt = true;
          console.log(`[ZIP] Static centroid index loaded: ${added} entries from GitHub (expected field ZIP_CODE).`);
          if (added < 30000) {
            console.warn('[ZIP] Entry count appears lower than expected (~32k). Verify source file completeness.');
            const previewKeys = Object.keys(index).slice(0,10);
            console.warn('[ZIP] First parsed ZIPs sample:', previewKeys.join(', '));
          }
          if (!added) {
            console.error('[ZIP] 0 centroid entries parsed. Check URL accessibility and JSON structure.');
          }
          return _zipCentroidIndex;
        } catch (e) {
          console.error('[ZIP] Failed to load static centroid index. Blue Triangles ZIP placement may be incomplete.', e);
          _zipCentroidIndexBuilt = true;
          _zipCentroidIndex = {};
          return _zipCentroidIndex;
        }
      }
      
      
      function findColumnIndex(headers, possibleNames) {
        for (const name of possibleNames) {
          const index = headers.findIndex(h => 
            h && h.toLowerCase().includes(name.toLowerCase())
          );
          if (index !== -1) return index;
        }
        return -1;
      }
      
      function createPopupContent(headers) {
        let content = "";
        const seen = new Set();
        headers.forEach(header => {
          if (header && header.toString().trim()) {
            const raw = header.toString().trim();
            if (raw === '_YearsExpNum') return;
            content += `<b>${raw}:</b> {${raw}}<br>`;
            seen.add(raw);
          }
        });
        const ensureField = (label, field) => {
          if (!seen.has(field)) {
            content += `<b>${label}:</b> {${field}}<br>`;
            seen.add(field);
          }
        };
        ensureField('City', 'City');
        ensureField('State', 'State');
        if (!seen.has('ZIP_Code')) {
          content += `<b>Zip Code:</b> {ZIP_Code}<br>`;
          seen.add('ZIP_Code');
        }
        return content;
      }
      
      const searchBoxInput = document.getElementById("searchBox");
      const searchSuggestions = document.getElementById("searchSuggestions");
      let zoomSearchInput = document.getElementById('zoomSearchBox');
      if (!zoomSearchInput) {
        zoomSearchInput = document.createElement('input');
        zoomSearchInput.type = 'text';
        zoomSearchInput.id = 'zoomSearchBox';
        zoomSearchInput.placeholder = 'Zoom to State or City';
        zoomSearchInput.style.cssText = 'width:220px; padding:6px 10px; border:1px solid #ccc; border-radius:4px; font-size:14px;';
      }
      let zoomSearchBtn = document.getElementById('zoomSearchGo');
      if (!zoomSearchBtn) {
        zoomSearchBtn = document.createElement('button');
        zoomSearchBtn.id = 'zoomSearchGo';
        zoomSearchBtn.textContent = 'Go';
        zoomSearchBtn.style.cssText = 'padding:6px 12px; border:1px solid #0a5; background:#0a5; color:#fff; border-radius:4px; cursor:pointer; font-size:14px;';
        zoomSearchBtn.onmouseenter = () => zoomSearchBtn.style.background = '#097';
        zoomSearchBtn.onmouseleave = () => zoomSearchBtn.style.background = '#0a5';
      }
      let helpBtn = document.getElementById('helpBtn');
      if (!helpBtn) {
        helpBtn = document.createElement('button');
        helpBtn.id = 'helpBtn';
        helpBtn.textContent = 'Help';
        helpBtn.title = 'Open usage guide in new tab';
  helpBtn.style.cssText = 'margin-left:6px; padding:6px 14px; background:#fff; color:#034d46; border:none; border-radius:4px; cursor:pointer; font-size:14px; font-weight:bold;';
  helpBtn.onmouseenter = () => helpBtn.style.background = '#f2f2f2';
  helpBtn.onmouseleave = () => helpBtn.style.background = '#fff';
        helpBtn.addEventListener('click', () => {
          window.open('webmap_help.html', '_blank', 'noopener');
        });
      }
      let __viewReady = false;
      if (view && view.when) {
        view.when(() => { __viewReady = true; });
      } else {
        setTimeout(()=>{ __viewReady = true; }, 1500);
      }


      const __STATE_EXTENTS = (function(){
        return {
          AL:[-88.473,30.144,-84.888,35.009], AK:[-179.15,51.21,-129.98,71.39], AZ:[-114.82,31.30,-109.04,37.00],
          AR:[-94.62,33.00,-89.64,36.50], CA:[-124.48,32.53,-114.13,42.01], CO:[-109.06,36.99,-102.04,41.00],
          CT:[-73.73,40.98,-71.78,42.05], DE:[-75.79,38.44,-75.05,39.84], FL:[-87.63,24.39,-80.03,31.00],
          GA:[-85.61,30.36,-80.84,35.00], HI:[-160.30,18.91,-154.70,22.24], ID:[-117.24,41.99,-111.05,49.00],
          IL:[-91.51,36.97,-87.02,42.51], IN:[-88.10,37.77,-84.79,41.76], IA:[-96.64,40.36,-90.14,43.50],
          KS:[-102.05,36.99,-94.60,40.00], KY:[-89.57,36.49,-81.96,39.15], LA:[-94.05,28.90,-88.81,33.02],
          ME:[-71.08,42.98,-66.89,47.46], MD:[-79.49,37.89,-75.05,39.73], MA:[-73.51,41.23,-69.93,42.89],
          MI:[-90.42,41.70,-82.13,48.31], MN:[-97.24,43.50,-89.49,49.39], MS:[-91.65,30.15,-88.10,35.00],
          MO:[-95.77,35.99,-89.10,40.61], MT:[-116.07,44.36,-104.04,49.00], NE:[-104.06,39.99,-95.31,43.01],
          NV:[-120.01,35.00,-114.04,42.00], NH:[-72.56,42.70,-70.70,45.31], NJ:[-75.56,38.92,-73.89,41.37],
          NM:[-109.05,31.33,-103.00,37.00], NY:[-79.77,40.48,-71.85,45.02], NC:[-84.33,33.83,-75.38,36.59],
          ND:[-104.07,45.93,-96.55,49.00], OH:[-84.82,38.40,-80.52,41.98], OK:[-103.00,33.62,-94.43,37.00],
          OR:[-124.70,41.99,-116.46,46.30], PA:[-80.53,39.72,-74.70,42.52], RI:[-71.90,41.09,-71.08,42.02],
          SC:[-83.36,32.05,-78.50,35.21], SD:[-104.06,42.48,-96.43,45.95], TN:[-90.31,34.98,-81.64,36.68],
          TX:[-106.65,25.83,-93.51,36.50], UT:[-114.05,36.99,-109.04,42.00], VT:[-73.44,42.72,-71.50,45.02],
          VA:[-83.68,36.54,-75.22,39.47], WA:[-124.85,45.54,-116.91,49.00], WV:[-82.69,37.20,-77.72,40.64],
          WI:[-92.89,42.49,-86.25,47.31], WY:[-111.06,40.99,-104.05,45.00], DC:[-77.12,38.78,-76.90,39.00]
        };
      })();
      const __STATE_NAME_TO_ABBR = (function(){
        const map = {
          'alabama':'AL','alaska':'AK','arizona':'AZ','arkansas':'AR','california':'CA','colorado':'CO','connecticut':'CT','delaware':'DE','florida':'FL','georgia':'GA','hawaii':'HI','idaho':'ID','illinois':'IL','indiana':'IN','iowa':'IA','kansas':'KS','kentucky':'KY','louisiana':'LA','maine':'ME','maryland':'MD','massachusetts':'MA','michigan':'MI','minnesota':'MN','mississippi':'MS','missouri':'MO','montana':'MT','nebraska':'NE','nevada':'NV','new hampshire':'NH','new jersey':'NJ','new mexico':'NM','new york':'NY','north carolina':'NC','north dakota':'ND','ohio':'OH','oklahoma':'OK','oregon':'OR','pennsylvania':'PA','rhode island':'RI','south carolina':'SC','south dakota':'SD','tennessee':'TN','texas':'TX','utah':'UT','vermont':'VT','virginia':'VA','washington':'WA','west virginia':'WV','wisconsin':'WI','wyoming':'WY','district of columbia':'DC','dc':'DC'
        };
        return map;
      })();

      async function tryZoomToState(raw) {
        if (!view || !__viewReady) { console.debug('State zoom: view not ready'); return false; }
        if (!raw) return false;
        const q = raw.trim().toLowerCase();
        let abbr = null;
        if (q.length === 2 && __STATE_EXTENTS[q.toUpperCase()]) {
          abbr = q.toUpperCase();
        } else if (__STATE_NAME_TO_ABBR[q]) {
          abbr = __STATE_NAME_TO_ABBR[q];
        }
        if (!abbr) { console.debug('State zoom: not a recognized state token', q); return false; }
        let extentGeom = null;
        if (dynamicStateExtents && dynamicStateExtents[abbr]) {
          const ext = dynamicStateExtents[abbr];
          extentGeom = { type: 'extent', xmin: ext[0], ymin: ext[1], xmax: ext[2], ymax: ext[3], spatialReference: { wkid: 4326 } };
        } else if (__STATE_EXTENTS[abbr]) { 
          const ext = __STATE_EXTENTS[abbr];
          extentGeom = { type: 'extent', xmin: ext[0], ymin: ext[1], xmax: ext[2], ymax: ext[3], spatialReference: { wkid: 4326 } };
        }
        if (!extentGeom) { console.warn('State zoom: no extent for', abbr, '(dynamic + static lookup failed)'); return false; }
        try {
          const before = view.extent ? view.extent.clone() : null;
          await view.goTo(extentGeom, { duration: 800 });
          const after = view.extent;
          let moved = true;
          if (before && after) {
            const dx = Math.abs((after.xmin + after.xmax)/2 - (before.xmin + before.xmax)/2);
            const dy = Math.abs((after.ymin + after.ymax)/2 - (before.ymin + before.ymax)/2);
            const threshold = 0.01; 
            if (dx < threshold && dy < threshold) moved = false;
          }
          if (!moved) {
            const cx = (extentGeom.xmin + extentGeom.xmax)/2;
            const cy = (extentGeom.ymin + extentGeom.ymax)/2;
            const width = Math.abs(extentGeom.xmax - extentGeom.xmin);
            const targetZoom = width > 20 ? 4 : width > 10 ? 5 : width > 5 ? 6 : width > 2 ? 7 : 8;
            await view.goTo({ center: [cx, cy], zoom: targetZoom }, { duration: 600 }).catch(()=>{});
            console.log('[Search] Fallback center zoom used for state', abbr);
          } else {
            const width = Math.abs(extentGeom.xmax - extentGeom.xmin);
            const cx = (extentGeom.xmin + extentGeom.xmax)/2;
            const cy = (extentGeom.ymin + extentGeom.ymax)/2;
            let targetZoom = 6; 
            if (width > 25) targetZoom = 5; 
            else if (width > 15) targetZoom = 5.5; 
            else if (width > 8) targetZoom = 6; 
            else if (width > 4) targetZoom = 6.5; 
            else if (width > 2) targetZoom = 7; 
            else if (width > 1) targetZoom = 7.5; 
            else targetZoom = 8; 
            if (typeof targetZoom === 'number') targetZoom = Math.round(targetZoom * 10)/10;
            await view.goTo({ center: [cx, cy], zoom: targetZoom }, { duration: 500 }).catch(()=>{});
            console.log('[Search] Zoomed to state (refined)', abbr, 'width=', width, 'zoom=', targetZoom);
          }
          return true;
        } catch(e) {
          console.warn('State zoom failed goTo', e);
          return false;
        }
      }
      if (searchBoxInput) {
        searchBoxInput.addEventListener('keydown', async (e) => {
          if (e.key === 'Enter') {
            const val = searchBoxInput.value;
            const zoomed = await tryZoomToState(val);
            if (zoomed) {
              searchSuggestions.style.display = 'none';
              searchSuggestions.innerHTML = '';
              e.preventDefault();
            }
          }
        });
      }
      const CITY_GEOJSON_URL = 'https://raw.githubusercontent.com/Link0923/Water_Treatment_Data/6899309fa150d0d0a62c29a7d853d9f22d37a7ed/US_Cities.geojson';
      let cityIndexBuilt = false;
      let cityNameIndex = {};
      let allCityEntries = [];
      let cityGraphicsLayer = null;

      async function buildCityIndex() {
        if (cityIndexBuilt) return;
        cityIndexBuilt = true;
        try {
          const resp = await fetch(CITY_GEOJSON_URL, { cache: 'no-cache' });
          if (!resp.ok) { console.warn('[City] Failed fetch', resp.status); return; }
            const gj = await resp.json();
          if (!gj || !Array.isArray(gj.features)) { console.warn('[City] Invalid GeoJSON structure'); return; }
          let added = 0;
          gj.features.forEach(f => {
            try {
              if (!f || !f.geometry || f.geometry.type !== 'Point') return;
              const coords = f.geometry.coordinates;
              if (!Array.isArray(coords) || coords.length < 2) return;
              const props = f.properties || {};
              const name = (props.NAME || props.Name || props.name || '').toString().trim();
              const state = (props.ST || props.State || props.state || '').toString().trim();
              if (!name || !state || state.length > 3 ? false : false) {
              }
              const lon = +coords[0];
              const lat = +coords[1];
              if (!isFinite(lon) || !isFinite(lat)) return;
              const nameLower = name.toLowerCase();
              const entry = { name, state, lon, lat };
              if (!cityNameIndex[nameLower]) cityNameIndex[nameLower] = [];
              cityNameIndex[nameLower].push(entry);
              allCityEntries.push(entry);
              added++;
            } catch(_e) {}
          });
          console.log(`[City] Indexed ${added} city points`);
          try {
            if (window.require) {
              window.require(['esri/layers/GraphicsLayer'], (GraphicsLayer) => {
                if (!cityGraphicsLayer) {
                  cityGraphicsLayer = new GraphicsLayer({ listMode: 'hide' });
                  if (map && map.add) map.add(cityGraphicsLayer);
                }
              });
            }
          } catch(_glErr) {}
        } catch(err) {
          console.warn('[City] buildCityIndex error', err);
        }
      }

      function highlightCity(lon, lat) {
        if (!window.require || !map || !view) return;
        window.require(['esri/Graphic'], (Graphic) => {
          if (!cityGraphicsLayer) return;
          cityGraphicsLayer.removeAll();
          const graphic = new Graphic({
            geometry: { type: 'point', longitude: lon, latitude: lat },
            symbol: { type: 'simple-marker', style: 'circle', color: [255,120,0,0.85], size: 12, outline: { color: 'white', width: 1.5 } }
          });
          cityGraphicsLayer.add(graphic);
          setTimeout(()=> { try { cityGraphicsLayer.remove(graphic); } catch(_){} }, 2500);
        });
      }

      function computePointExtent(lon, lat, bufferDeg) {
        const b = bufferDeg || 0.2; 
        return { type:'extent', xmin: lon - b, ymin: lat - b, xmax: lon + b, ymax: lat + b, spatialReference: { wkid: 4326 } };
      }

      function parseCityInput(raw) {
        if (!raw) return null;
        let city = raw.trim();
        let state = null;
        if (city.includes(',')) {
          const parts = city.split(',');
          city = parts[0].trim();
          state = parts[1].trim();
        }
        return { city, state };
      }

      function chooseCityEntry(entries, desiredState) {
        if (!entries || !entries.length) return null;
        if (desiredState) {
          const dsLower = desiredState.toLowerCase();
          const normState = __STATE_NAME_TO_ABBR[dsLower] ? __STATE_NAME_TO_ABBR[dsLower] : desiredState.toUpperCase();
          const byState = entries.find(e => e.state.toUpperCase() === normState);
          if (byState) return byState;
        }
        return entries[0];
      }

      async function tryZoomToCity(raw) {
        if (!view || !__viewReady) return false;
        if (!raw) return false;
        await buildCityIndex();
        const parsed = parseCityInput(raw);
        if (!parsed || !parsed.city) return false;
        const nameLower = parsed.city.toLowerCase();
        const entries = cityNameIndex[nameLower];
        if (entries && entries.length) {
          const sel = chooseCityEntry(entries, parsed.state);
          if (sel) {
            let nearbyCount = 0;
            const sampleRadiusDeg = 0.6; // ~65km
            const lon = sel.lon, lat = sel.lat;
            const countIfNear = (g) => {
              if (!g || !g.geometry) return;
              const gg = g.geometry;
              const gx = gg.longitude !== undefined ? gg.longitude : gg.x;
              const gy = gg.latitude !== undefined ? gg.latitude : gg.y;
              if (!isFinite(gx) || !isFinite(gy)) return;
              if (Math.abs(gx - lon) <= sampleRadiusDeg && Math.abs(gy - lat) <= sampleRadiusDeg) nearbyCount++;
            };
            try { professionalsData.slice(0,5000).forEach(countIfNear); } catch(_){}
            try { blueTrianglesData.slice(0,5000).forEach(countIfNear); } catch(_){}
            let targetZoom = 11; 
            if (nearbyCount < 5) targetZoom = 12;
            else if (nearbyCount < 15) targetZoom = 11.5;
            else if (nearbyCount < 40) targetZoom = 11;
            else if (nearbyCount < 100) targetZoom = 10.5;
            else targetZoom = 10; 
            targetZoom = Math.round(targetZoom * 10)/10;
            try {
              await view.goTo({ center: [lon, lat], zoom: targetZoom }, { duration: 800 });
              highlightCity(lon, lat);
              console.log('[Search] Zoomed to city (indexed, density heuristic)', sel.name, sel.state, 'nearby=', nearbyCount, 'zoom=', targetZoom);
              return true;
            } catch(e) {
              console.warn('[City] center goTo failed, fallback to extent', e);
              const extent = computePointExtent(sel.lon, sel.lat, 0.35);
              try { await view.goTo(extent, { duration: 700 }); highlightCity(sel.lon, sel.lat); return true; } catch(_){}
            }
          }
        }
        const legacyExtent = (function findLegacyCityExtent(query) {
          if (!query) return null;
          const raw = query.trim();
          if (!raw) return null;
          let cityPart = raw;
          let statePart = null;
          if (raw.includes(',')) {
            const parts = raw.split(',');
            cityPart = parts[0].trim();
            statePart = parts[1].trim().toLowerCase();
          }
          const cityLower = cityPart.toLowerCase();
          const matches = [];
          const pushIf = (f) => { if (f && f.geometry && f.attributes) matches.push(f); };
          const stateMatch = (attrState) => {
            if (!statePart) return true;
            if (!attrState) return false;
            const st = attrState.toString().trim().toLowerCase();
            if (st === statePart) return true;
            const ab = __STATE_NAME_TO_ABBR[statePart];
            if (ab && st === ab.toLowerCase()) return true;
            const full = Object.keys(__STATE_NAME_TO_ABBR).find(k => __STATE_NAME_TO_ABBR[k] === statePart.toUpperCase());
            if (full && st === full) return true;
            return false;
          };
          professionalsData.forEach(f => {
            const a = f.attributes || {};
            if (a.City && a.City.toString().trim().toLowerCase() === cityLower && stateMatch(a.State)) pushIf(f);
          });
          blueTrianglesData.forEach(f => {
            const a = f.attributes || {};
            const cityAttr = a.City || a.city || a.CITY;
            if (cityAttr && cityAttr.toString().trim().toLowerCase() === cityLower && stateMatch(a.State || a.STATE || a.state)) pushIf(f);
          });
          if (!matches.length) return null;
          let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
          matches.forEach(f => {
            const g = f.geometry;
            if (g.type === 'point') {
              xmin = Math.min(xmin, g.longitude || g.x);
              xmax = Math.max(xmax, g.longitude || g.x);
              ymin = Math.min(ymin, g.latitude || g.y);
              ymax = Math.max(ymax, g.latitude || g.y);
            } else if (g.extent) {
              xmin = Math.min(xmin, g.extent.xmin);
              ymin = Math.min(ymin, g.extent.ymin);
              xmax = Math.max(xmax, g.extent.xmax);
              ymax = Math.max(ymax, g.extent.ymax);
            }
          });
          if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return null;
          const dx = (xmax - xmin) || 0.2;
          const dy = (ymax - ymin) || 0.2;
          const pad = 0.15;
          return { type: 'extent', xmin: xmin - dx * pad, ymin: ymin - dy * pad, xmax: xmax + dx * pad, ymax: ymax + dy * pad, spatialReference: { wkid: 4326 } };
        })(raw);
        if (legacyExtent) {
          try {
            await view.goTo(legacyExtent, { duration: 700 });
            console.log('[Search] Zoomed to city (legacy fallback)', raw);
            return true;
          } catch(e2) { console.warn('[City] legacy goTo failed', e2); }
        }
        return false;
      }

      function handleZoomSearchSubmit() {
        const val = zoomSearchInput.value.trim();
        if (!val) return;
        // Try state first, then city
        tryZoomToState(val).then(stateOk => {
          if (stateOk) return; 
          return tryZoomToCity(val);
        });
      }

      if (zoomSearchInput) {
        zoomSearchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            handleZoomSearchSubmit();
            e.preventDefault();
          }
        });
      }
      if (zoomSearchBtn) {
        zoomSearchBtn.addEventListener('click', () => handleZoomSearchSubmit());
      }
      (function ensureZoomSearchUI(){
        const wrapper = document.getElementById('secondarySearchWrapper');
        if (wrapper) {
          if (!document.getElementById('zoomSearchBox')) wrapper.appendChild(zoomSearchInput);
          if (!document.getElementById('zoomSearchGo')) wrapper.appendChild(zoomSearchBtn);
        } else {
          const host = document.getElementById('searchContainer') || document.querySelector('#searchBox')?.parentElement || document.body;
          if (host) {
            if (!document.getElementById('zoomSearchBox')) host.appendChild(zoomSearchInput);
            if (!document.getElementById('zoomSearchGo')) host.appendChild(zoomSearchBtn);
          }
        }
      })();
      let locationSuggestDiv = document.getElementById('stateSuggest');
      if (!locationSuggestDiv) {
        locationSuggestDiv = document.createElement('div');
        locationSuggestDiv.id = 'stateSuggest';
        locationSuggestDiv.style.cssText = 'position:absolute; z-index:9999; background:#fff; border:1px solid #ccc; border-radius:4px; box-shadow:0 2px 6px rgba(0,0,0,0.15); max-height:260px; overflow-y:auto; display:none; font-size:13px;';
        document.body.appendChild(locationSuggestDiv);
      }

      const allStatesList = Object.entries(__STATE_NAME_TO_ABBR).reduce((acc,[name,abbr]) => {
        if (abbr.length === 2) acc.push({ name: name.replace(/\b\w/g,c=>c.toUpperCase()), abbr });
        return acc;
      }, []).filter((v,i,a)=> a.findIndex(o=>o.abbr===v.abbr)===i).sort((a,b)=> a.name.localeCompare(b.name));

      function positionLocationSuggest() {
        if (!zoomSearchInput) return;
        const rect = zoomSearchInput.getBoundingClientRect();
        locationSuggestDiv.style.left = (window.scrollX + rect.left) + 'px';
        locationSuggestDiv.style.top = (window.scrollY + rect.bottom + 4) + 'px';
        locationSuggestDiv.style.width = rect.width + 'px';
      }

      function hideLocationSuggestions(){
        locationSuggestDiv.style.display='none';
        locationSuggestDiv.innerHTML='';
      }

      function renderLocationSuggestions(filter) {
        const q = (filter||'').trim().toLowerCase();
        if (!q) { hideLocationSuggestions(); return; }
        positionLocationSuggest();
        let html = '';
        // States
        const stateMatches = allStatesList.filter(s => s.name.toLowerCase().startsWith(q) || s.abbr.toLowerCase().startsWith(q));
        if (stateMatches.length) {
          html += `<div style='padding:4px 8px; font-weight:bold; background:#eef5ff; color:#084b7f;'>States</div>`;
          html += stateMatches.slice(0,15).map(m => `<div data-type='state' data-abbr='${m.abbr}' style='padding:6px 8px; cursor:pointer; display:flex; justify-content:space-between;'>
            <span>${m.name}</span><span style='color:#555; font-size:11px;'>${m.abbr}</span>
          </div>`).join('');
        }
        if (allCityEntries.length) {
          const cityMatches = allCityEntries.filter(c => c.name.toLowerCase().startsWith(q));
          if (cityMatches.length) {
            html += `<div style='padding:4px 8px; font-weight:bold; background:#f4f9f4; color:#0a5;'>Cities</div>`;
            html += cityMatches.slice(0,25).map(c => `<div data-type='city' data-city='${c.name.replace(/'/g,"&apos;")}' data-state='${c.state}' style='padding:6px 8px; cursor:pointer; display:flex; justify-content:space-between;'>
                <span>${c.name}</span><span style='color:#555; font-size:11px;'>${c.state}</span>
            </div>`).join('');
          }
        }
        if (!html) {
          html = `<div style='padding:8px; color:#777;'>No matches</div>`;
        }
        locationSuggestDiv.innerHTML = html;
        locationSuggestDiv.style.display='block';
      }

      async function applyStateSuggestion(abbr) {
        if (!abbr) return;
        zoomSearchInput.value = abbr;
        hideLocationSuggestions();
        await tryZoomToState(abbr);
      }
      async function applyCitySuggestion(name, state) {
        if (!name) return;
        const token = state ? `${name}, ${state}` : name;
        zoomSearchInput.value = token;
        hideLocationSuggestions();
        await tryZoomToCity(token);
      }

      if (zoomSearchInput) {
        zoomSearchInput.addEventListener('input', async () => {
          if (!cityIndexBuilt) buildCityIndex();
          renderLocationSuggestions(zoomSearchInput.value);
        });
        zoomSearchInput.addEventListener('focus', () => {
          if (zoomSearchInput.value.trim()) renderLocationSuggestions(zoomSearchInput.value);
        });
      }
      locationSuggestDiv.addEventListener('click', (e) => {
        const stateEl = e.target.closest('div[data-type="state"][data-abbr]');
        const cityEl = e.target.closest('div[data-type="city"][data-city]');
        if (stateEl) {
          const abbr = stateEl.getAttribute('data-abbr');
            applyStateSuggestion(abbr);
        } else if (cityEl) {
          const city = cityEl.getAttribute('data-city');
          const st = cityEl.getAttribute('data-state');
            applyCitySuggestion(city, st);
        }
      });
      document.addEventListener('click', (e) => {
        if (e.target === zoomSearchInput || locationSuggestDiv.contains(e.target)) return;
        hideLocationSuggestions();
      });


      function getKeyFields(layerType) {
        if (layerType === 'professionals') {
          return [
            'First_name', 'Last_name', 'Company', 'Parent Company', 'City', 'State', 'Role_Category', 'Role Category', 'Professional_Index', 'Email', 'Title', 'Zip Code', 'CBSA_code', 'CBSA-Name'
          ];
        } else if (layerType === 'blue') {
          return [
            'Company', 'City', 'State', 'Domain', 'Zip code',
          ];
        }
        return [];
      }

      function featureToSearchString(feature, layerType) {
        const attrs = feature.attributes || {};
        const keyFields = getKeyFields(layerType);
        return keyFields.map(f => (attrs[f] || '').toString().toLowerCase()).join(' ');
      }
      function featureLabel(feature, maxFields = 3) {
        const attrs = feature.attributes || {};
        let keys = [];
        if (attrs['First_name'] && attrs['Last_name']) {
          keys = ['Professional_Index', 'First_name', 'Last_name'];
        } else if (attrs['Company'] && attrs['City']) {
          keys = ['Company', 'City', 'State'];
        } else {
          keys = Object.keys(attrs).filter(k => attrs[k] && typeof attrs[k] === 'string');
        }
        return keys.slice(0, maxFields).map(k => `<b>${k}:</b> ${attrs[k]}`).join(' | ');
      }

      searchBoxInput.addEventListener("input", function(e) {
        const q = searchBoxInput.value.trim().toLowerCase();
        if (!q) {
          searchSuggestions.style.display = "none";
          searchSuggestions.innerHTML = "";
          return;
        }
        const words = q.split(/\s+/).filter(Boolean);
        const maxPerLayer = 8;
        function matchesAllWords(feature, layerType) {
          const searchStr = featureToSearchString(feature, layerType);
          return words.every(word => searchStr.includes(word));
        }
        const proMatches = professionalsData.filter(f => matchesAllWords(f, 'professionals')).slice(0, maxPerLayer);
        const blueMatches = blueTrianglesData.filter(f => matchesAllWords(f, 'blue')).slice(0, maxPerLayer);
        
        let html = "";
        if (proMatches.length) {
          html += `<div style='padding:4px 8px; font-weight:bold; color:#034d46; background:#e6f2ef;'>Water Treatment Professionals</div>`;
          proMatches.forEach(f => {
            html += `<div class='search-suggestion' data-layer='professionals' data-oid='${f.attributes.ObjectID}' style='padding:4px 8px; cursor:pointer;'>${featureLabel(f)}</div>`;
          });
        }
        if (blueMatches.length) {
          html += `<div style='padding:4px 8px; font-weight:bold; color:#003366; background:#e6eaff;'>Water Facilities</div>`;
          blueMatches.forEach(f => {
            html += `<div class='search-suggestion' data-layer='blue' data-oid='${f.attributes.ObjectID}' style='padding:4px 8px; cursor:pointer;'>${featureLabel(f)}</div>`;
          });
        }
        
        if (!html) html = `<div style='padding:8px; color:#888;'>No matches found</div>`;
        searchSuggestions.innerHTML = html;
        searchSuggestions.style.display = "block";
      });
      document.addEventListener("click", function(e) {
        if (!searchSuggestions.contains(e.target) && e.target !== searchBoxInput) {
          searchSuggestions.style.display = "none";
        }
      });
      let highlightHandle = null;
      searchSuggestions.addEventListener("click", async function(e) {
        const el = e.target.closest('.search-suggestion');
        if (!el) return;
        const layerType = el.getAttribute('data-layer');
        const oid = parseInt(el.getAttribute('data-oid'));
        let layerRef = null, dataArr = null;
        if (layerType === 'professionals') {
          layerRef = professionalsLayerRef;
          dataArr = professionalsData;
        } else if (layerType === 'blue') {
          layerRef = blueTrianglesLayerRef;
          dataArr = blueTrianglesData;
        }
        if (!layerRef || !dataArr) return;
        const feature = dataArr.find(f => f.attributes.ObjectID == oid);
        if (!feature) return;
        if (feature.geometry && feature.geometry.longitude !== undefined && feature.geometry.latitude !== undefined) {
          view.goTo({
            center: [feature.geometry.longitude, feature.geometry.latitude],
            zoom: 12
          });
        }
        try {
          const layerView = await view.whenLayerView(layerRef);
          if (highlightHandle) highlightHandle.remove();
          highlightHandle = layerView.highlight([{ ObjectID: oid }]);
          setTimeout(() => {
            if (highlightHandle) highlightHandle.remove();
            highlightHandle = null;
          }, 2500);
        } catch (err) {
        }
        searchSuggestions.style.display = "none";
      });

      loadData();

    const layersBtn = document.getElementById("layersBtn");
    const layersDropdown = document.getElementById("layersDropdown");
    layersBtn.addEventListener("click", function(e) {
      e.stopPropagation();
      layersDropdown.style.display = layersDropdown.style.display === "block" ? "none" : "block";
    });
    document.addEventListener("click", function(e) {
      if (!layersDropdown.contains(e.target) && e.target !== layersBtn) {
        layersDropdown.style.display = "none";
      }
    });

    document.getElementById("chkProfessionals").addEventListener("change", function(e) {
      if (professionalsLayerRef) professionalsLayerRef.visible = e.target.checked;
    });
    document.getElementById("chkCounties").addEventListener("change", function(e) {
      if (countiesLayerRef) countiesLayerRef.visible = e.target.checked;
      if (countiesLayerRef && countiesLayerRef.visible) {
        scheduleCountyShading();
      }
    });
    document.getElementById("chkPostalCodes").addEventListener("change", function(e) {
      if (postalCodesLayerRef) postalCodesLayerRef.visible = e.target.checked;
    });
    document.getElementById("chkBlueTriangles").addEventListener("change", function(e) {
      if (blueTrianglesLayerRef) blueTrianglesLayerRef.visible = e.target.checked;
    });
    

    const manipulatorPane = document.getElementById("manipulatorPane");
    const manipulatorCloseBtn = document.getElementById("manipulatorCloseBtn");
  const manipulatorContent = document.getElementById("manipulatorContent");
    manipulatorCloseBtn.addEventListener("click", function() {
      manipulatorPane.style.display = 'none';
    });
  const legendBtn = document.getElementById("legendBtn");
  const mapLegend = document.getElementById("mapLegend");

    let filterState = {
      roleCategories: new Set(),
      parentCompanies: new Set(),
      enabledRoles: new Set(),
      enabledCompanies: new Set(),
      companyMinThreshold: null, 
      experienceMin: null,
      experienceMax: null,
      experienceActive: false,
      experienceFieldName: null
    };

    function getProfessionalsUniqueValues(field) {
      if (!professionalsData.length) return [];
      const values = new Set();
      professionalsData.forEach(f => {
        const v = f.attributes[field];
        if (v && v.toString().trim()) values.add(v.toString().trim());
      });
      return Array.from(values).sort();
    }

    const filterBtn = document.getElementById("filterBtn");
    filterBtn.addEventListener("click", function() {
      if (!manipulatorPane) return;
      const advPane = document.getElementById('advancedSelectionPane');
      if (advPane && advPane.style.display !== 'none') advPane.style.display = 'none';
      const currentlyVisible = getComputedStyle(manipulatorPane).display !== 'none';
      if (currentlyVisible) {
        // Toggle off (close)
        manipulatorPane.style.display = 'none';
        return;
      }
      manipulatorPane.style.display = 'flex';
      if (manipulatorContent) {
        const adv = document.getElementById('advancedSelectionSection');
        if (adv) adv.remove();
        manipulatorContent.innerHTML = '<div id="filterOptionsSection" style="color:#888;">Loading filters…</div>';
      }
      renderFilterUI();
    });

      function renderFilterUI() {
      const roleField = professionalsData.length && (professionalsData[0].attributes["Role_Category"] !== undefined ? "Role_Category" : (professionalsData[0].attributes["Role Category"] !== undefined ? "Role Category" : null));
      const companyField = professionalsData.length && (professionalsData[0].attributes["Parent Company"] !== undefined ? "Parent Company" : null);
      const roles = roleField ? getProfessionalsUniqueValues(roleField) : [];
  let companies = companyField ? getProfessionalsUniqueValues(companyField) : [];
      if (!filterState.enabledRoles.size) roles.forEach(r => filterState.enabledRoles.add(r));
      if (!filterState.enabledCompanies.size) companies.forEach(c => filterState.enabledCompanies.add(c));
      let html = `
        <div style='font-weight:bold; font-size:17px; margin-bottom:6px; color:#1a3a5b;'>Filter Professionals</div>
  <div id='experienceFilterBlock' style='background:#faf8f1; border:1px solid #ddd; padding:8px 10px; border-radius:6px; margin:6px 0 14px 0;'>
          <div style='font-weight:600; font-size:13px; color:#333; margin-bottom:6px; display:flex; align-items:center; justify-content:space-between;'>
            <span>Years of Experience</span>
            <button id='experienceToggleBtn' style='padding:4px 10px; background:${filterState.experienceActive ? '#b80000' : '#034d46'}; color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:12px; font-weight:600;'>${filterState.experienceActive ? 'Clear' : 'Initiate'}</button>
          </div>
          <div style='display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;'>
            <div style='display:flex; flex-direction:column;'>
              <label style='font-size:11px; font-weight:600; color:#555; letter-spacing:0.3px;'>Min</label>
              <input id='expMinInput' type='number' min='0' placeholder='e.g. 2' value='${filterState.experienceMin ?? ''}' style='padding:5px 8px; width:90px; border:1px solid #bbb; border-radius:4px; font-size:13px;' ${filterState.experienceActive ? 'disabled' : ''} />
            </div>
            <div style='display:flex; flex-direction:column;'>
              <label style='font-size:11px; font-weight:600; color:#555; letter-spacing:0.3px;'>Max</label>
              <input id='expMaxInput' type='number' min='0' placeholder='e.g. 20' value='${filterState.experienceMax ?? ''}' style='padding:5px 8px; width:90px; border:1px solid #bbb; border-radius:4px; font-size:13px;' ${filterState.experienceActive ? 'disabled' : ''} />
            </div>
            <div style='flex:1; font-size:11px; color:#666; line-height:1.3;'>${filterState.experienceActive ? 'Active range applied.' : 'Leave Max blank for ≥ Min. Leave Min blank for ≤ Max.'}</div>
          </div>
        </div>
        <div style='display:flex; gap:10px; margin-bottom:12px; flex-wrap:wrap;'>
          <button id='roleCheckAllBtn' style='padding:4px 12px; background:#034d46; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer; font-size:13px;'>Check All</button>
          <button id='roleClearAllBtn' style='padding:4px 12px; background:#b80000; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer; font-size:13px;'>Clear All</button>
        </div>`;
      if (roles.length) {
        html += `<div style='margin-bottom:10px;'><span style='font-weight:bold;'>Role Category</span><br>`;
        roles.forEach(role => {
          const checked = filterState.enabledRoles.has(role) ? 'checked' : '';
          html += `<label style='display:block; margin:2px 0;'><input type='checkbox' class='filter-role' value="${role.replace(/"/g,'&quot;')}" ${checked}> ${role}</label>`;
        });
        html += `</div>`;
      }
      if (companies.length) {
        if (filterState.companyMinThreshold && professionalsData.length && companyField) {
          const counts = {};
          professionalsData.forEach(f => {
            const v = f.attributes[companyField];
            if (v) counts[v] = (counts[v] || 0) + 1;
          });
          companies = companies.filter(c => (counts[c] || 0) >= filterState.companyMinThreshold);
        }
        html += `<div style='margin-bottom:10px;'>
          <span style='font-weight:bold;'>Parent Company${filterState.companyMinThreshold ? ` (≥${filterState.companyMinThreshold})` : ''}</span>
          <div style='display:flex; gap:8px; margin:6px 0 10px 0; flex-wrap:wrap;'>
            <button id='companyCheckAllBtn' style='padding:3px 10px; background:#034d46; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer; font-size:12px;'>Check All</button>
            <button id='companyClearAllBtn' style='padding:3px 10px; background:#b80000; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer; font-size:12px;'>Clear All</button>
            <button id='company10PlusBtn' style='padding:3px 10px; background:#555; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer; font-size:12px;' title='Show only parent companies with 10 or more professionals'>10 or more</button>
            ${filterState.companyMinThreshold ? `<button id='companyShowAllBtn' style='padding:3px 10px; background:#777; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer; font-size:12px;' title='Show all parent companies again'>Show All</button>` : ''}
          </div>`;
        if (!companies.length && filterState.companyMinThreshold) {
          html += `<div style='color:#b00; font-size:13px; margin:4px 0 8px 0;'>No companies meet the ≥${filterState.companyMinThreshold} threshold.</div>`;
        }
        companies.forEach(company => {
          const checked = filterState.enabledCompanies.has(company) ? 'checked' : '';
          html += `<label style='display:block; margin:2px 0;'><input type='checkbox' class='filter-company' value="${company.replace(/"/g,'&quot;')}" ${checked}> ${company}</label>`;
        });
        html += `</div>`;
      }
      if (!roles.length && !companies.length) {
        html += `<div style='color:#888;'>No filterable fields found in professionals layer.</div>`;
      }
      if (manipulatorContent) {
        const adv2 = document.getElementById('advancedSelectionSection');
        if (adv2) adv2.remove();
        manipulatorContent.innerHTML = html;
      }
      const expToggleBtn = document.getElementById('experienceToggleBtn');
      const expMinInput = document.getElementById('expMinInput');
      const expMaxInput = document.getElementById('expMaxInput');
      if (expToggleBtn) {
        expToggleBtn.addEventListener('click', () => {
          if (!filterState.experienceActive) {
            let minVal = expMinInput && expMinInput.value !== '' ? parseFloat(expMinInput.value) : null;
            let maxVal = expMaxInput && expMaxInput.value !== '' ? parseFloat(expMaxInput.value) : null;
            if (minVal != null && minVal < 0) minVal = 0;
            if (maxVal != null && maxVal < 0) maxVal = 0;
            if (minVal != null && maxVal != null && maxVal < minVal) { const t = minVal; minVal = maxVal; maxVal = t; }
            filterState.experienceMin = minVal;
            filterState.experienceMax = maxVal;
            filterState.experienceActive = (minVal != null || maxVal != null);
            console.log('[ExperienceFilter] Activated', { min:minVal, max:maxVal });
          } else {
            filterState.experienceMin = null;
            filterState.experienceMax = null;
            filterState.experienceActive = false;
            console.log('[ExperienceFilter] Cleared');
          }
          renderFilterUI();
          applyProfessionalsFilter();
        });
      }
      const expBlock = document.getElementById('experienceFilterBlock');
      if (expBlock) {
        let badge = expBlock.querySelector('.exp-field-badge');
        if (!badge) {
          badge = document.createElement('div');
          badge.className = 'exp-field-badge';
          badge.style.cssText = 'margin-top:4px; font-size:10px; color:#555; font-style:italic;';
          expBlock.appendChild(badge);
        }
        badge.textContent = filterState.experienceFieldName ? `Field: ${filterState.experienceFieldName}` : 'Field not found';
      }
        document.querySelectorAll('.filter-role').forEach(cb => {
          cb.addEventListener('change', function(e) {
            if (e.target.checked) filterState.enabledRoles.add(e.target.value);
            else filterState.enabledRoles.delete(e.target.value);
            applyProfessionalsFilter();
          });
        });
        document.querySelectorAll('.filter-company').forEach(cb => {
          cb.addEventListener('change', function(e) {
            if (e.target.checked) filterState.enabledCompanies.add(e.target.value);
            else filterState.enabledCompanies.delete(e.target.value);
            applyProfessionalsFilter();
          });
        });
      const roleCheckAllBtn = document.getElementById('roleCheckAllBtn');
      if (roleCheckAllBtn) {
        roleCheckAllBtn.addEventListener('click', () => {
          document.querySelectorAll('.filter-role').forEach(cb => {
            if (!cb.checked) cb.checked = true;
            filterState.enabledRoles.add(cb.value);
          });
          applyProfessionalsFilter();
        });
      }
      const roleClearAllBtn = document.getElementById('roleClearAllBtn');
      if (roleClearAllBtn) {
        roleClearAllBtn.addEventListener('click', () => {
          document.querySelectorAll('.filter-role').forEach(cb => {
            if (cb.checked) cb.checked = false;
            filterState.enabledRoles.delete(cb.value);
          });
          applyProfessionalsFilter();
        });
      }
      const companyCheckAllBtn = document.getElementById('companyCheckAllBtn');
      if (companyCheckAllBtn) {
        companyCheckAllBtn.addEventListener('click', () => {
          document.querySelectorAll('.filter-company').forEach(cb => {
            if (!cb.checked) cb.checked = true;
            filterState.enabledCompanies.add(cb.value);
          });
          applyProfessionalsFilter();
        });
      }
      const companyClearAllBtn = document.getElementById('companyClearAllBtn');
      if (companyClearAllBtn) {
        companyClearAllBtn.addEventListener('click', () => {
          document.querySelectorAll('.filter-company').forEach(cb => {
            if (cb.checked) cb.checked = false;
            filterState.enabledCompanies.delete(cb.value);
          });
          applyProfessionalsFilter();
        });
      }
      const company10PlusBtn = document.getElementById('company10PlusBtn');
      if (company10PlusBtn) {
        company10PlusBtn.addEventListener('click', () => {
          if (!professionalsData.length) return;
          // Determine actual company field name
          let companyFieldName = null;
          const a0 = professionalsData[0].attributes || {};
          if (a0['Parent_Company'] !== undefined) companyFieldName = 'Parent_Company';
          else if (a0['Parent Company'] !== undefined) companyFieldName = 'Parent Company';
          if (!companyFieldName) return;
          const counts = {};
          professionalsData.forEach(f => {
            const v = f.attributes[companyFieldName];
            if (v) counts[v] = (counts[v] || 0) + 1;
          });
          const keep = Object.keys(counts).filter(k => counts[k] >= 10);
          if (!keep.length) {
            alert('No parent companies have 10 or more professionals.');
            return;
          }
          filterState.companyMinThreshold = 10;
          filterState.enabledCompanies.clear();
          keep.forEach(c => filterState.enabledCompanies.add(c));
          renderFilterUI();
          applyProfessionalsFilter();
        });
      }
      const companyShowAllBtn = document.getElementById('companyShowAllBtn');
      if (companyShowAllBtn) {
        companyShowAllBtn.addEventListener('click', () => {
          filterState.companyMinThreshold = null;
          if (companyField) {
            const allCompanies = getProfessionalsUniqueValues(companyField);
            filterState.enabledCompanies.clear();
            allCompanies.forEach(c => filterState.enabledCompanies.add(c));
          }
          renderFilterUI();
          applyProfessionalsFilter();
        });
      }
    }

    function applyProfessionalsFilter() {
      if (!professionalsLayerRef) return;
      let roleField = null;
      let companyField = null;
      let experienceField = filterState.experienceFieldName || null;
      if (professionalsData.length) {
        const attrs = professionalsData[0].attributes;
  if (attrs["Role_Category"] !== undefined) roleField = "Role_Category";
  else if (attrs["Role Category"] !== undefined) roleField = "Role Category";
        else {
          const rk = Object.keys(attrs).find(k => k && k.toString().replace(/[_\s]/g,'').toLowerCase().includes('rolecategory'));
          if (rk) roleField = rk;
        }
  if (attrs["Parent_Company"] !== undefined) companyField = "Parent_Company";
  else if (attrs["Parent Company"] !== undefined) companyField = "Parent Company";
        else {
          const ck = Object.keys(attrs).find(k => k && k.toString().replace(/[_\s]/g,'').toLowerCase() === 'parentcompany');
          if (ck) companyField = ck;
        }
        if (!experienceField) {
          const keys = Object.keys(attrs);
          experienceField = keys.find(k => k.toLowerCase() === 'years experience (numeric)' || k.toLowerCase() === 'years_experience_(numeric)') || null;
          if (!experienceField) {
            const targetNorm = 'yearsexperiencenumeric';
            experienceField = keys.find(k => k.toLowerCase().replace(/[^a-z0-9]/g,'') === targetNorm) || null;
          }
          if (!experienceField) {
            experienceField = keys.find(k => /experience/i.test(k)) || null;
          }
          if (experienceField) {
            filterState.experienceFieldName = experienceField;
            console.log('[ExperienceField] Resolved to', experienceField);
          } else {
            console.log('[ExperienceField] Not found among attributes');
          }
        }
      }
    const safeField = (f) => (f && /[^A-Za-z0-9_]/.test(f) ? '"' + f + '"' : f);
      let clauses = [];
      if (roleField) {
        const allRoles = getProfessionalsUniqueValues(roleField);
        if (allRoles.length > 0) {
          if (filterState.enabledRoles.size > 0 && filterState.enabledRoles.size < allRoles.length) {
            const valsArr = Array.from(filterState.enabledRoles).map(v => `'${v.replace(/'/g, "''")}'`);
            if (valsArr.length > 0) {
              clauses.push(`${safeField(roleField)} IN (${valsArr.join(',')})`);
            }
          }
        }
      }
      if (companyField) {
        const allCompanies = getProfessionalsUniqueValues(companyField);
        if (allCompanies.length > 0) {
          if (filterState.enabledCompanies.size > 0 && filterState.enabledCompanies.size < allCompanies.length) {
            const valsArr = Array.from(filterState.enabledCompanies).map(v => `'${v.replace(/'/g, "''")}'`);
            if (valsArr.length > 0) {
              clauses.push(`${safeField(companyField)} IN (${valsArr.join(',')})`);
            }
          }
        }
      }
      if (filterState.experienceActive && experienceField) {
        const emin = filterState.experienceMin;
        const emax = filterState.experienceMax;
        const hasDerived = professionalsData.length && professionalsData[0].attributes && professionalsData[0].attributes['_YearsExpNum'] !== undefined;
        const fieldForQuery = hasDerived ? '_YearsExpNum' : experienceField;
        if (hasDerived) {
          console.log('[ExperienceFilter] Using derived field _YearsExpNum for querying');
        }
        if (emin != null && emax != null) {
          clauses.push(`${safeField(fieldForQuery)} >= ${emin} AND ${safeField(fieldForQuery)} <= ${emax}`);
        } else if (emin != null) {
          clauses.push(`${safeField(fieldForQuery)} >= ${emin}`);
        } else if (emax != null) {
          clauses.push(`${safeField(fieldForQuery)} <= ${emax}`);
        }
      }
      if (clauses.length) {
        let where = clauses.join(' AND ');
        where = where.replace(/\s+/g, ' ').trim();
        professionalsLayerRef.definitionExpression = where;
        try { console.debug('Filter where:', where); } catch (e) {}
        try {
          const w = where && where.length ? where : null;
          view.whenLayerView(professionalsLayerRef).then(lv => { lv.filter = w ? { where: w } : null; });
        } catch (e) {}
      } else {
  professionalsLayerRef.definitionExpression = null;
        try { console.debug('Filter cleared'); } catch (e) {}
        try {
          view.whenLayerView(professionalsLayerRef).then(lv => { lv.filter = null; });
        } catch (e) {}
      }
      if (typeof updateMapCounter === 'function') {
        updateMapCounter();
      }
      try { if (countiesLayerRef && countiesLayerRef.visible) scheduleCountyShading(); } catch(e) {}
  try {
    if (mapLegend && mapLegend.style.display === 'block') { updateLegend(); }
  } catch (e) {}
    }

    const toolboxDiv = document.getElementById('toolbox');
    if (toolboxDiv) {
      toolboxDiv.style.display = 'flex';
      toolboxDiv.style.flexDirection = 'row';
      toolboxDiv.style.alignItems = 'center';
      toolboxDiv.style.justifyContent = 'flex-start';
      toolboxDiv.style.gap = '0';
    }
    let leftControls = document.getElementById('toolbox-left-controls');
    if (!leftControls) {
      leftControls = document.createElement('div');
      leftControls.id = 'toolbox-left-controls';
      leftControls.style.display = 'flex';
      leftControls.style.flexDirection = 'row';
      leftControls.style.alignItems = 'center';
      leftControls.style.flexGrow = '1';
      leftControls.style.gap = '16px';
      while (toolboxDiv.firstChild) {
        leftControls.appendChild(toolboxDiv.firstChild);
      }
      toolboxDiv.appendChild(leftControls);
    }

    const csvExportBtn = document.createElement('button');
    csvExportBtn.id = 'csvExportBtn';
    csvExportBtn.textContent = 'CSV Export';
    csvExportBtn.style.padding = '6px 14px';
    csvExportBtn.style.background = '#fff';
    csvExportBtn.style.color = '#034d46';
    csvExportBtn.style.borderRadius = '4px';
    csvExportBtn.style.border = 'none';
    csvExportBtn.style.fontWeight = 'bold';
    csvExportBtn.style.cursor = 'pointer';
  csvExportBtn.style.marginLeft = '3px';
    csvExportBtn.style.marginRight = '0px';
    if (searchBoxInput && searchBoxInput.parentNode === leftControls) {
      if (!document.getElementById('zoomSearchBox')) {
        if (searchBoxInput.nextSibling) {
          leftControls.insertBefore(zoomSearchInput, searchBoxInput.nextSibling);
          leftControls.insertBefore(zoomSearchBtn, zoomSearchInput.nextSibling);
        } else {
          leftControls.appendChild(zoomSearchInput);
          leftControls.appendChild(zoomSearchBtn);
        }
      }
      if (searchBoxInput.nextSibling) {
        leftControls.insertBefore(csvExportBtn, searchBoxInput.nextSibling);
      } else {
        leftControls.appendChild(csvExportBtn);
      }
      if (!document.getElementById('helpBtn')) {
        leftControls.insertBefore(helpBtn, csvExportBtn.nextSibling);
      } else {
        const existingHelp = document.getElementById('helpBtn');
        if (existingHelp && existingHelp.parentNode !== leftControls) leftControls.insertBefore(existingHelp, csvExportBtn.nextSibling);
      }
    } else {
      leftControls.appendChild(csvExportBtn);
      if (!document.getElementById('zoomSearchBox')) {
        leftControls.appendChild(zoomSearchInput);
        leftControls.appendChild(zoomSearchBtn);
      }
      if (!document.getElementById('helpBtn')) {
        leftControls.appendChild(helpBtn);
      }
    }

    csvExportBtn.addEventListener('click', function() {

      function matchesDefinitionExpression(feature, layerRef) {
        if (!layerRef || !layerRef.definitionExpression) return true;
        const expr = layerRef.definitionExpression;
        const clauses = expr.split(/\s+AND\s+/i);
        for (const clause of clauses) {
          const match = clause.match(/^"?([^"]+?)"?\s+IN\s+\(([^)]+)\)$/);
          if (match) {
            const field = match[1];
            const allowed = match[2].split(/,(?=(?:[^']*'[^']*')*[^']*$)/).map(s => s.trim().replace(/^'/, '').replace(/'$/, '').replace(/''/g, "'"));
            const val = feature.attributes[field] || '';
            if (!allowed.includes(val)) return false;
          } else if (clause.trim() === '1=0') {
            return false;
          }
        }
        return true;
      }


      let selected = window._lastSelectedFeatures || {
        professionals: [],
        blue: []
      };
      if (typeof selectHighlightHandle === 'object' && selectHighlightHandle.selectedFeatures) {
        selected = selectHighlightHandle.selectedFeatures;
      }


      let filteredProfessionals = [];
      if (selected.professionals && selected.professionals.length) {
        filteredProfessionals = selected.professionals.filter(f => matchesDefinitionExpression(f, professionalsLayerRef));
      }

      let filteredBlue = [];
      if (selected.blue && selected.blue.length) {
        if (blueTrianglesLayerRef && blueTrianglesLayerRef.definitionExpression) {
          const expr = blueTrianglesLayerRef.definitionExpression;
          filteredBlue = selected.blue.filter(f => matchesDefinitionExpression(f, blueTrianglesLayerRef));
        } else {
          filteredBlue = selected.blue.slice();
        }
      }

      if ((!filteredProfessionals.length) && (!filteredBlue.length)) {
        let triedQuery = false;
        if (blueTrianglesLayerRef && blueTrianglesLayerRef.visible) {
          try {
            triedQuery = true;
          } catch(e) { console.warn('Blue layer query attempt failed', e); }
        }
        if (!filteredProfessionals.length && !filteredBlue.length) {
          alert('No features are selected. Use the Select tool to select points first.');
          return;
        }
      }

      function featuresToCSV(features) {
        if (!features.length) return '';
        const headers = Object.keys(features[0].attributes);
        const escape = v => '"' + (v == null ? '' : (''+v).replace(/"/g,'""')) + '"';
        const rows = [headers.map(escape).join(',')];
        features.forEach(f => {
          rows.push(headers.map(h => escape(f.attributes[h])).join(','));
        });
        return rows.join('\r\n');
      }

      let html = `<!DOCTYPE html><html><head><title>CSV Export</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
          .tabs { display: flex; border-bottom: 1px solid #ccc; }
          .tab { padding: 10px 24px; cursor: pointer; border: none; background: #f5f5f5; font-weight: bold; }
          .tab.active { background: #fff; border-bottom: 2px solid #034d46; color: #034d46; }
          .csv-content { display: none; padding: 18px; font-size: 15px; }
          .csv-content.active { display: block; }
          textarea { width: 100%; height: 400px; font-family: monospace; font-size: 14px; }
        </style>
      </head><body>`;
      html += `<div class='tabs'>`;
      const tabOrder = [];
      if (filteredProfessionals.length) {
        html += `<button class='tab active'>Professionals (${filteredProfessionals.length})</button>`;
        tabOrder.push('professionals');
      }
      if (filteredBlue.length) {
        html += `<button class='tab${tabOrder.length ? '' : ' active'}'>Water Facilities (${filteredBlue.length})</button>`;
        tabOrder.push('blue');
      }
      
      html += `</div>`;
      tabOrder.forEach((key, i) => {
        let features = [];
        if (key === 'professionals') {
          features = filteredProfessionals;
        } else {
          features = filteredBlue;
        }
        html += `<div class='csv-content${i === 0 ? ' active' : ''}' id='csvTab${i}'>`;
        html += `<textarea readonly>${featuresToCSV(features)}</textarea>`;
        html += `<br><button class='download-csv-btn' data-idx='${i}' style="margin-top:8px; padding:6px 18px; background:#034d46; color:#fff; border:none; border-radius:4px; font-weight:bold; cursor:pointer;">Download CSV</button>`;
        html += `</div>`;
      });
      html += `<script>(function(){
        var tabs = document.querySelectorAll('.tab');
        var contents = document.querySelectorAll('.csv-content');
        tabs.forEach(function(tab, idx) {
          tab.addEventListener('click', function() {
            tabs.forEach(function(t, i) { t.classList.remove('active'); contents[i].classList.remove('active'); });
            tab.classList.add('active');
            contents[idx].classList.add('active');
          });
        });
        var downloadBtns = document.querySelectorAll('.download-csv-btn');
        downloadBtns.forEach(function(btn, idx) {
          btn.addEventListener('click', function() {
            var text = contents[idx].querySelector('textarea').value;
            var blob = new Blob([text], {type:'text/csv'});
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = tabs[idx].textContent.replace(/\s*\(.*\)/, '') + '.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(function(){ URL.revokeObjectURL(url); }, 1000);
          });
        });
      })();<\/script><\/body><\/html>`;
      const win = window.open('', '_blank');
      win.document.write(html);
      win.document.close();
    });
    const counterDiv = document.createElement('div');
    counterDiv.id = 'mapCounterOverlay';
    counterDiv.style.display = 'block';
    counterDiv.style.color = '#034d46';
    counterDiv.style.fontWeight = 'bold';
    counterDiv.style.fontSize = '15px';
    counterDiv.style.textAlign = 'right';
    counterDiv.style.marginLeft = '24px';
    counterDiv.style.padding = '0 12px';
    counterDiv.style.background = 'none';
    counterDiv.style.border = 'none';
    counterDiv.style.boxShadow = 'none';
    counterDiv.style.pointerEvents = 'none';
    counterDiv.style.minWidth = '260px';
    counterDiv.style.flexShrink = '0';
    toolboxDiv.appendChild(counterDiv);

    async function updateMapCounter() {
      if (!view) return;
      const extent = view.extent;
      async function countFeatures(layerRef) {
        if (!layerRef || !layerRef.visible) return 0;
        try {
          const where = layerRef.definitionExpression && layerRef.definitionExpression.trim() ? layerRef.definitionExpression : '1=1';
          const result = await layerRef.queryFeatureCount({
            geometry: extent,
            spatialRelationship: 'intersects',
            where: where
          });
          return result;
        } catch (e) {
          return 0;
        }
      }
      const [proCount, blueCount] = await Promise.all([
        countFeatures(professionalsLayerRef),
        countFeatures(blueTrianglesLayerRef)
      ]);
      const total = proCount + blueCount; 
      let html = '';
      html += `<span style='color:#f5f2e6;'>Professionals:</span> <b style='color:#fff;'>${proCount}</b> &nbsp;`;
      html += `<span style='color:#0074D9;'>Water Facilities:</span> <b style='color:#fff;'>${blueCount}</b> &nbsp;`;
      html += `<span style='color:#888;'>Total:</span> <b style='color:#fff;'>${total}</b>`;
      counterDiv.innerHTML = html;
    }

    function setupCounterEvents() {
      if (!view) return;
      require(["esri/core/reactiveUtils"], function(reactiveUtils) {
        reactiveUtils.watch(
          () => view.extent,
          () => { updateMapCounter(); if (countiesLayerRef && countiesLayerRef.visible) scheduleCountyShading(); }
        );
      });
      [
        document.getElementById('chkProfessionals'),
        document.getElementById('chkBlueTriangles')
      ].forEach(cb => {
        if (cb) cb.addEventListener('change', updateMapCounter);
      });
      setTimeout(updateMapCounter, 1200);
    }

    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(setupCounterEvents);
    } else {
      setTimeout(setupCounterEvents, 500);
    }

  const advancedSelectionBtn = document.getElementById('advancedSelectionBtn');
  const advancedSelectionPane = document.getElementById('advancedSelectionPane');
  const advancedSelectionCloseBtn = document.getElementById('advancedSelectionCloseBtn');
  let selectMode = null;
    let selectGraphicsLayer = null;
    let selectDragHandler = null;
    let selectLassoPoints = [];
    let selectHighlightHandle = null;

    function deactivateSelectTool() {
      if (selectGraphicsLayer && view) {
        view.map.remove(selectGraphicsLayer);
        selectGraphicsLayer = null;
      }
      if (selectDragHandler) {
        selectDragHandler.remove();
        selectDragHandler = null;
      }
      if (selectHighlightHandle) {
        selectHighlightHandle.remove();
        selectHighlightHandle = null;
      }
      selectLassoPoints = [];
      selectMode = null;
    }

    document.getElementById("viewDiv").addEventListener("contextmenu", function(e) {
      e.preventDefault();
      deactivateSelectTool();
    });
    function updateAdvSelStatus(msg) { const el = document.getElementById('advancedSelectionStatus'); if (el) el.textContent = msg; }

    function showAdvancedSelectionPane() {
      // Hide filter pane if open
      if (manipulatorPane.style.display !== 'none') manipulatorPane.style.display = 'none';
      advancedSelectionPane.style.display = 'flex';
      updateAdvSelStatus('Choose a selection mode.');
      console.log('[AdvancedSelection] Pane opened');
      const checkAllBtn = document.getElementById('wcCheckAllBtn');
      const clearAllBtn = document.getElementById('wcClearAllBtn');
      const applyBtn = document.getElementById('wcApplyBtn');
      const container = document.getElementById('waterCompanySelection');
      if (checkAllBtn && !checkAllBtn._wired) {
        checkAllBtn.addEventListener('click', () => {
          if (!container) return;
          container.querySelectorAll('input.wc-opt[type="checkbox"]').forEach(cb => { cb.checked = true; });
        });
        checkAllBtn._wired = true;
      }
      if (clearAllBtn && !clearAllBtn._wired) {
        clearAllBtn.addEventListener('click', () => {
          if (!container) return;
          container.querySelectorAll('input.wc-opt[type="checkbox"]').forEach(cb => { cb.checked = false; });
        });
        clearAllBtn._wired = true;
      }
      if (applyBtn && !applyBtn._wired) {
        applyBtn.addEventListener('click', () => {
          if (!container) return;
          const selected = Array.from(container.querySelectorAll('input.wc-opt[type="checkbox"]:checked')).map(cb => cb.value);
          console.log('[WaterCompanySelection] Apply clicked. Selected options:', selected);
          const serviceRadio = container.querySelector('input[name="wcServiceYN"]:checked');
          const serviceVal = serviceRadio ? serviceRadio.value : 'ANY';
          if (!blueTrianglesLayerRef) {
            console.warn('[WaterCompanySelection] Blue Triangles layer not ready yet.');
            return;
          }
          if (!waterCompanyServiceField) {
            console.warn('[WaterCompanySelection] Service field not detected; cannot apply service filter.');
          }
          let expr = null;
          if (waterCompanyServiceField) {
            const filterField = blueTrianglesLayerRef.fields.find(f => f.name === waterCompanyServiceAliasField) ? waterCompanyServiceAliasField : waterCompanyServiceField;
            if (serviceVal === 'YES') expr = `${filterField} = 'Y'`;
            else if (serviceVal === 'NO') expr = `${filterField} = 'N'`;
            if (filterField === waterCompanyServiceAliasField) {
              const distinctAlias = Array.from(new Set(blueTrianglesData.map(f => f.attributes && f.attributes[waterCompanyServiceAliasField]).filter(v => v)));
              console.log('[WaterCompanySelection] Alias distinct values:', distinctAlias);
            } else {
              const distinctOrig = Array.from(new Set(blueTrianglesData.map(f => f.attributes && f.attributes[waterCompanyServiceField]).filter(v => v)));
              console.log('[WaterCompanySelection] Original field distinct values:', distinctOrig);
            }
          }
          const hvacCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="HVAC water treatment services"]');
          const hvacChecked = hvacCheckbox ? hvacCheckbox.checked : false;
          if (hvacChecked) {
            const hvacAlias = '_HVAC';
            const hvacFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === hvacAlias);
            if (hvacFieldExists) {
              const hvacExpr = `${hvacAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${hvacExpr}` : hvacExpr;
            } else {
              console.warn('[WaterCompanySelection] HVAC alias field not present on layer; cannot apply HVAC filter.');
            }
          }
          const coolingCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Cooling Water Treatment services"]');
          const coolingChecked = coolingCheckbox ? coolingCheckbox.checked : false;
          if (coolingChecked) {
            const coolingAlias = '_COOLING';
            const coolingFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === coolingAlias);
            if (coolingFieldExists) {
              const coolingExpr = `${coolingAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${coolingExpr}` : coolingExpr;
            } else {
              console.warn('[WaterCompanySelection] Cooling alias field not present on layer; cannot apply Cooling filter.');
            }
          }
          const heatingCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Heating/Boiler Water Treatment services"]');
          const heatingChecked = heatingCheckbox ? heatingCheckbox.checked : false;
          if (heatingChecked) {
            const heatingAlias = '_HEATING';
            const heatingFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === heatingAlias);
            if (heatingFieldExists) {
              const heatingExpr = `${heatingAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${heatingExpr}` : heatingExpr;
            } else {
              console.warn('[WaterCompanySelection] Heating alias field not present on layer; cannot apply Heating filter.');
            }
          }

          const filtrationCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Filtration/Separation or Reverse Osmosis water treatment services"]');
          const filtrationChecked = filtrationCheckbox ? filtrationCheckbox.checked : false;
          if (filtrationChecked) {
            const filtrationAlias = '_FILTRATION';
            const filtrationFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === filtrationAlias);
            if (filtrationFieldExists) {
              const filtrationExpr = `${filtrationAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${filtrationExpr}` : filtrationExpr;
            } else {
              console.warn('[WaterCompanySelection] Filtration alias field not present on layer; cannot apply Filtration filter.');
            }
          }

          const ultrapureCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Ultrapure water treatment"]');
          const ultrapureChecked = ultrapureCheckbox ? ultrapureCheckbox.checked : false;
          if (ultrapureChecked) {
            const ultrapureAlias = '_ULTRAPURE';
            const ultrapureFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === ultrapureAlias);
            if (ultrapureFieldExists) {
              const ultrapureExpr = `${ultrapureAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${ultrapureExpr}` : ultrapureExpr;
            } else {
              console.warn('[WaterCompanySelection] Ultrapure alias field not present on layer; cannot apply Ultrapure filter.');
            }
          }

          const wastewaterCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Wastewater treatment"]');
          const wastewaterChecked = wastewaterCheckbox ? wastewaterCheckbox.checked : false;
          if (wastewaterChecked) {
            const wastewaterAlias = '_WASTEWATER';
            const wastewaterFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === wastewaterAlias);
            if (wastewaterFieldExists) {
              const wastewaterExpr = `${wastewaterAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${wastewaterExpr}` : wastewaterExpr;
            } else {
              console.warn('[WaterCompanySelection] Wastewater alias field not present on layer; cannot apply Wastewater filter.');
            }
          }

          const glycolCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Glycol"]');
          const glycolChecked = glycolCheckbox ? glycolCheckbox.checked : false;
          if (glycolChecked) {
            const glycolAlias = '_GLYCOL';
            const glycolFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === glycolAlias);
            if (glycolFieldExists) {
              const glycolExpr = `${glycolAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${glycolExpr}` : glycolExpr;
            } else {
              console.warn('[WaterCompanySelection] Glycol alias field not present on layer; cannot apply Glycol filter.');
            }
          }

          const cleaningCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Cleaning / Sanitization / Disinfection"]');
          const cleaningChecked = cleaningCheckbox ? cleaningCheckbox.checked : false;
          if (cleaningChecked) {
            const cleaningAlias = '_CLEANING';
            const cleaningFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === cleaningAlias);
            if (cleaningFieldExists) {
              const cleaningExpr = `${cleaningAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${cleaningExpr}` : cleaningExpr;
            } else {
              console.warn('[WaterCompanySelection] Cleaning alias field not present on layer; cannot apply Cleaning filter.');
            }
          }

          const legionellaCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Legionella or other regulatory testing"]');
          const legionellaChecked = legionellaCheckbox ? legionellaCheckbox.checked : false;
          if (legionellaChecked) {
            const legionellaAlias = '_LEGIONELLA';
            const legionellaFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === legionellaAlias);
            if (legionellaFieldExists) {
              const legionellaExpr = `${legionellaAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${legionellaExpr}` : legionellaExpr;
            } else {
              console.warn('[WaterCompanySelection] Legionella alias field not present on layer; cannot apply Legionella filter.');
            }
          }

          const chemicalBlendingCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Chemical Blending, specialty formulation, private label for water treatment"]');
          const chemicalBlendingChecked = chemicalBlendingCheckbox ? chemicalBlendingCheckbox.checked : false;
          if (chemicalBlendingChecked) {
            const chemicalBlendingAlias = '_CHEMICALBLENDING';
            const chemicalBlendingFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === chemicalBlendingAlias);
            if (chemicalBlendingFieldExists) {
              const chemicalBlendingExpr = `${chemicalBlendingAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${chemicalBlendingExpr}` : chemicalBlendingExpr;
            } else {
              console.warn('[WaterCompanySelection] Chemical Blending alias field not present on layer; cannot apply Chemical Blending filter.');
            }
          }

          const manufacturingCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Manufacturing or assembly: Pumps / Controls / sensors"]');
          const manufacturingChecked = manufacturingCheckbox ? manufacturingCheckbox.checked : false;
          if (manufacturingChecked) {
            const manufacturingAlias = '_MANUFACTURING';
            const manufacturingFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === manufacturingAlias);
            if (manufacturingFieldExists) {
              const manufacturingExpr = `${manufacturingAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${manufacturingExpr}` : manufacturingExpr;
            } else {
              console.warn('[WaterCompanySelection] Manufacturing alias field not present on layer; cannot apply Manufacturing filter.');
            }
          }   
          
          const installationCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Installation and/or maintenance: Pumps / Controls / sensors"]');
          const installationChecked = installationCheckbox ? installationCheckbox.checked : false;
          if (installationChecked) {
            const installationAlias = '_INSTALLATION';
            const installationFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === installationAlias);
            if (installationFieldExists) {
              const installationExpr = `${installationAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${installationExpr}` : installationExpr;
            } else {
              console.warn('[WaterCompanySelection] Installation alias field not present on layer; cannot apply Installation filter.');
            }
          } 

          const manufacturing1Checkbox = container.querySelector('input.wc-opt[type="checkbox"][value="Manufacturing or assembly: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators"]');
          const manufacturing1Checked = manufacturing1Checkbox ? manufacturing1Checkbox.checked : false;
          if (manufacturing1Checked) {
            const manufacturing1Alias = '_MANUFACTURING1';
            const manufacturing1FieldExists = blueTrianglesLayerRef.fields.find(f => f.name === manufacturing1Alias);
            if (manufacturing1FieldExists) {
              const manufacturing1Expr = `${manufacturing1Alias} = '1'`;
              expr = expr ? `(${expr}) AND ${manufacturing1Expr}` : manufacturing1Expr;
            } else {
              console.warn('[WaterCompanySelection] Manufacturing1 alias field not present on layer; cannot apply Manufacturing filter.');
            }
          } 

          const installation1Checkbox = container.querySelector('input.wc-opt[type="checkbox"][value="Installation and/or maintenance: Water treatment equipment - Filters, membrane systems, Reverse Osmosis (RO), softeners, chlorine or ozone generators"]');
          const installation1Checked = installation1Checkbox ? installation1Checkbox.checked : false;
          if (installation1Checked) {
            const installation1Alias = '_INSTALLATION1';
            const installation1FieldExists = blueTrianglesLayerRef.fields.find(f => f.name === installation1Alias);
            if (installation1FieldExists) {
              const installation1Expr = `${installation1Alias} = '1'`;
              expr = expr ? `(${expr}) AND ${installation1Expr}` : installation1Expr;
            } else {
              console.warn('[WaterCompanySelection] Installation1 alias field not present on layer; cannot apply Installation filter.');
            }
          } 

          const commercialCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Commercial / office / apartment / warehouse facilities - general"]');
          const commercialChecked = commercialCheckbox ? commercialCheckbox.checked : false;
          if (commercialChecked) {
            const commercialAlias = '_COMMERCIAL';
            const commercialFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === commercialAlias);
            if (commercialFieldExists) {
              const commercialExpr = `${commercialAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${commercialExpr}` : commercialExpr;
            } else {
              console.warn('[WaterCompanySelection] Commercial alias field not present on layer; cannot apply Commercial filter.');
            }
          } 

          const hospitalityCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Hospitality, e.g., hotels and restaurants"]');
          const hospitalityChecked = hospitalityCheckbox ? hospitalityCheckbox.checked : false;
          if (hospitalityChecked) {
            const hospitalityAlias = '_HOSPITALITY';
            const hospitalityFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === hospitalityAlias);
            if (hospitalityFieldExists) {
              const hospitalityExpr = `${hospitalityAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${hospitalityExpr}` : hospitalityExpr;
            } else {
              console.warn('[WaterCompanySelection] Hospitality alias field not present on layer; cannot apply Hospitality filter.');
            }
          } 

          const healthcareCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Healthcare / hospitals"]');
          const healthcareChecked = healthcareCheckbox ? healthcareCheckbox.checked : false;
          if (healthcareChecked) {
            const healthcareAlias = '_HEALTHCARE';
            const healthcareFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === healthcareAlias);
            if (healthcareFieldExists) {
              const healthcareExpr = `${healthcareAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${healthcareExpr}` : healthcareExpr;
            } else {
              console.warn('[WaterCompanySelection] Healthcare alias field not present on layer; cannot apply Healthcare filter.');
            }
          } 

          const educationCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Education / schools + universities"]');
          const educationChecked = educationCheckbox ? educationCheckbox.checked : false;
          if (educationChecked) {
            const educationAlias = '_EDUCATION';
            const educationFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === educationAlias);
            if (educationFieldExists) {
              const educationExpr = `${educationAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${educationExpr}` : educationExpr;
            } else {
              console.warn('[WaterCompanySelection] Education alias field not present on layer; cannot apply Education filter.');
            }
          } 

          const governmentCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Government facilities"]');
          const governmentChecked = governmentCheckbox ? governmentCheckbox.checked : false;
          if (governmentChecked) {
            const governmentAlias = '_GOVERNMENT';
            const governmentFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === governmentAlias);
            if (governmentFieldExists) {
              const governmentExpr = `${governmentAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${governmentExpr}` : governmentExpr;
            } else {
              console.warn('[WaterCompanySelection] Government alias field not present on layer; cannot apply Government filter.');
            }
          } 

          const industrialCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Industrial or Manufacturing facilities - general"]');
          const industrialChecked = industrialCheckbox ? industrialCheckbox.checked : false;
          if (industrialChecked) {
            const industrialAlias = '_INDUSTRIAL';
            const industrialFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === industrialAlias);
            if (industrialFieldExists) {
              const industrialExpr = `${industrialAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${industrialExpr}` : industrialExpr;
            } else {
              console.warn('[WaterCompanySelection] Industrial alias field not present on layer; cannot apply Industrial filter.');
            }
          } 

          const pharmaceuticalCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Pharmaceutical manufacturing"]');
          const pharmaceuticalChecked = pharmaceuticalCheckbox ? pharmaceuticalCheckbox.checked : false;
          if (pharmaceuticalChecked) {
            const pharmaceuticalAlias = '_PHARMACEUTICAL';
            const pharmaceuticalFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === pharmaceuticalAlias);
            if (pharmaceuticalFieldExists) {
              const pharmaceuticalExpr = `${pharmaceuticalAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${pharmaceuticalExpr}` : pharmaceuticalExpr;
            } else {
              console.warn('[WaterCompanySelection] Pharmaceutical alias field not present on layer; cannot apply Pharmaceutical filter.');
            }
          } 

          const dataCentersCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Data centers"]');
          const dataCentersChecked = dataCentersCheckbox ? dataCentersCheckbox.checked : false;
          if (dataCentersChecked) {
            const dataCentersAlias = '_DATA_CENTERS';
            const dataCentersFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === dataCentersAlias);
            if (dataCentersFieldExists) {
              const dataCentersExpr = `${dataCentersAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${dataCentersExpr}` : dataCentersExpr;
            } else {
              console.warn('[WaterCompanySelection] Data centers alias field not present on layer; cannot apply Data centers filter.');
            }
          } 

          const foodBeverageCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Food and/or beverage processing + manufacture"]');
          const foodBeverageChecked = foodBeverageCheckbox ? foodBeverageCheckbox.checked : false;
          if (foodBeverageChecked) {
            const foodBeverageAlias = '_FOOD_BEVERAGE';
            const foodBeverageFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === foodBeverageAlias);
            if (foodBeverageFieldExists) {
              const foodBeverageExpr = `${foodBeverageAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${foodBeverageExpr}` : foodBeverageExpr;
            } else {
              console.warn('[WaterCompanySelection] Food and/or beverage processing + manufacture alias field not present on layer; cannot apply Food and/or beverage processing + manufacture filter.');
            }
          } 

          const agricultureCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Agriculture - general"]');
          const agricultureChecked = agricultureCheckbox ? agricultureCheckbox.checked : false;
          if (agricultureChecked) {
            const agricultureAlias = '_AGRICULTURE';
            const agricultureFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === agricultureAlias);
            if (agricultureFieldExists) {
              const agricultureExpr = `${agricultureAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${agricultureExpr}` : agricultureExpr;
            } else {
              console.warn('[WaterCompanySelection] Agriculture - general alias field not present on layer; cannot apply Agriculture - general filter.');
            }
          } 

          const agriculture1Checkbox = container.querySelector('input.wc-opt[type="checkbox"][value="Agriculture - irrigation, crops"]');
          const agriculture1Checked = agriculture1Checkbox ? agriculture1Checkbox.checked : false;
          if (agriculture1Checked) {
            const agriculture1Alias = '_AGRICULTURE1';
            const agriculture1FieldExists = blueTrianglesLayerRef.fields.find(f => f.name === agriculture1Alias);
            if (agriculture1FieldExists) {
              const agriculture1Expr = `${agriculture1Alias} = '1'`;
              expr = expr ? `(${expr}) AND ${agriculture1Expr}` : agriculture1Expr;
            } else {
              console.warn('[WaterCompanySelection] Agriculture - irrigation, crops alias field not present on layer; cannot apply Agriculture - irrigation, crops filter.');
            }
          } 

          const agriculture2Checkbox = container.querySelector('input.wc-opt[type="checkbox"][value="Agriculture - livestock / aquaculture"]');
          const agriculture2Checked = agriculture2Checkbox ? agriculture2Checkbox.checked : false;
          if (agriculture2Checked) {
            const agriculture2Alias = '_AGRICULTURE2';
            const agriculture2FieldExists = blueTrianglesLayerRef.fields.find(f => f.name === agriculture2Alias);
            if (agriculture2FieldExists) {
              const agriculture2Expr = `${agriculture2Alias} = '1'`;
              expr = expr ? `(${expr}) AND ${agriculture2Expr}` : agriculture2Expr;
            } else {
              console.warn('[WaterCompanySelection] Agriculture - livestock / aquaculture alias field not present on layer; cannot apply Agriculture - livestock / aquaculture filter.');
            }
          } 

          const municipalCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Municipal / Public drinking water"]');
          const municipalChecked = municipalCheckbox ? municipalCheckbox.checked : false;
          if (municipalChecked) {
            const municipalAlias = '_MUNICIPAL';
            const municipalFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === municipalAlias);
            if (municipalFieldExists) {
              const municipalExpr = `${municipalAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${municipalExpr}` : municipalExpr;
            } else {
              console.warn('[WaterCompanySelection] Municipal / Public drinking water alias field not present on layer; cannot apply Municipal / Public drinking water filter.');
            }
          } 

          const municipal1Checkbox = container.querySelector('input.wc-opt[type="checkbox"][value="Municipal / Public wastewater"]');
          const municipal1Checked = municipal1Checkbox ? municipal1Checkbox.checked : false;
          if (municipal1Checked) {
            const municipal1Alias = '_MUNICIPAL1';
            const municipal1FieldExists = blueTrianglesLayerRef.fields.find(f => f.name === municipal1Alias);
            if (municipal1FieldExists) {
              const municipal1Expr = `${municipal1Alias} = '1'`;
              expr = expr ? `(${expr}) AND ${municipal1Expr}` : municipal1Expr;
            } else {
              console.warn('[WaterCompanySelection] Municipal / Public wastewater alias field not present on layer; cannot apply Municipal / Public wastewater filter.');
            }
          } 

          const plumbingCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Plumbing / HVAC contractors"]');
          const plumbingChecked = plumbingCheckbox ? plumbingCheckbox.checked : false;
          if (plumbingChecked) {
            const plumbingAlias = '_PLUMBING';
            const plumbingFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === plumbingAlias);
            if (plumbingFieldExists) {
              const plumbingExpr = `${plumbingAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${plumbingExpr}` : plumbingExpr;
            } else {
              console.warn('[WaterCompanySelection] Plumbing / HVAC contractors alias field not present on layer; cannot apply Plumbing / HVAC contractors filter.');
            }
          } 

          const domesticCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Domestic / non-commercial residential"]');
          const domesticChecked = domesticCheckbox ? domesticCheckbox.checked : false;
          if (domesticChecked) {
            const domesticAlias = '_DOMESTIC';
            const domesticFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === domesticAlias);
            if (domesticFieldExists) {
              const domesticExpr = `${domesticAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${domesticExpr}` : domesticExpr;
            } else {
              console.warn('[WaterCompanySelection] Domestic / non-commercial residential alias field not present on layer; cannot apply Domestic / non-commercial residential filter.');
            }
          } 

          const labCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Lab services"]');
          const labChecked = labCheckbox ? labCheckbox.checked : false;
          if (labChecked) {
            const labAlias = '_LAB';
            const labFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === labAlias);
            if (labFieldExists) {
              const labExpr = `${labAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${labExpr}` : labExpr;
            } else {
              console.warn('[WaterCompanySelection] Lab services alias field not present on layer; cannot apply Lab services filter.');
            }
          } 

          const engineeringCheckbox = container.querySelector('input.wc-opt[type="checkbox"][value="Engineering design"]');
          const engineeringChecked = engineeringCheckbox ? engineeringCheckbox.checked : false;
          if (engineeringChecked) {
            const engineeringAlias = '_ENGINEERING';
            const engineeringFieldExists = blueTrianglesLayerRef.fields.find(f => f.name === engineeringAlias);
            if (engineeringFieldExists) {
              const engineeringExpr = `${engineeringAlias} = '1'`;
              expr = expr ? `(${expr}) AND ${engineeringExpr}` : engineeringExpr;
            } else {
              console.warn('[WaterCompanySelection] Engineering design capability source field not found (expected: "Engineering design")');
            }
          } 

          blueTrianglesLayerRef.definitionExpression = expr; 
          if (!blueTrianglesLayerRef.visible) blueTrianglesLayerRef.visible = true;
          console.log('[WaterCompanySelection] Applied service filter value:', serviceVal, 'expression:', expr || '(none)');
          try { updateMapCounter(); } catch(e) { console.warn('Counter update failed', e); }
          try {
            const advStatus = document.getElementById('advancedSelectionStatus');
            if (advStatus) {
              (async () => {
                if (typeof professionalsLayerRef !== 'undefined' && professionalsLayerRef) {
                  const proCnt = await professionalsLayerRef.queryFeatureCount({ where: professionalsLayerRef.definitionExpression || '1=1' });
                  const blueCnt = await blueTrianglesLayerRef.queryFeatureCount({ where: blueTrianglesLayerRef.definitionExpression || '1=1' });
                  advStatus.textContent = `Selected Professionals: ${proCnt}${blueTrianglesLayerRef && blueTrianglesLayerRef.visible ? ` | Blue Triangles: ${blueCnt}` : ''}`;
                }
              })();
            }
          } catch(e) {}
        });
        applyBtn._wired = true;
      }
    }
    function hideAdvancedSelectionPane() { advancedSelectionPane.style.display = 'none'; }

    advancedSelectionBtn.addEventListener('click', showAdvancedSelectionPane);
    advancedSelectionCloseBtn.addEventListener('click', hideAdvancedSelectionPane);

    document.getElementById('btnSquareSelect').addEventListener('click', () => { selectMode = 'square'; activateSelectMode(selectMode); updateAdvSelStatus('Square selection active. Drag to draw rectangle.'); });
    document.getElementById('btnLassoSelect').addEventListener('click', () => { selectMode = 'lasso'; activateSelectMode(selectMode); updateAdvSelStatus('Lasso selection active. Drag to trace shape.'); });
    document.getElementById('btnClearSelection').addEventListener('click', () => { deactivateSelectTool(); updateAdvSelStatus('Selection cleared.'); });

    const zipSelectInput = document.getElementById('zipSelectInput');
    const zipRadiusInput = document.getElementById('zipRadiusInput');
    const btnZipRadiusGo = document.getElementById('btnZipRadiusGo');
    const zipRadiusStatus = document.getElementById('zipRadiusStatus');

    function setZipRadiusStatus(msg, isError=false) {
      if (!zipRadiusStatus) return;
      zipRadiusStatus.style.color = isError ? '#b00000' : '#555';
      zipRadiusStatus.textContent = msg;
    }

    async function selectByZipRadius(zipRaw, milesRaw) {
      if (!_zipCentroidIndexBuilt || !_zipCentroidIndex) {
        setZipRadiusStatus('ZIP index not loaded yet.', true);
        console.warn('[ZIP Radius] Index not yet available');
        return;
      }
      if (!zipRaw) { setZipRadiusStatus('Enter a ZIP.', true); return; }
      let zip = zipRaw.toString().trim().replace(/[^0-9]/g,'');
      if (zip.length >= 9) zip = zip.substring(0,5);
      if (zip.length === 4) zip = '0'+zip; else if (zip.length === 3) zip = '00'+zip;
      if (zip.length !== 5) { setZipRadiusStatus('Provide a valid 5-digit ZIP.', true); return; }
      const centroid = _zipCentroidIndex[zip];
      if (!centroid) { setZipRadiusStatus('ZIP not found in index.', true); return; }
      let miles = parseFloat(milesRaw);
      if (isNaN(miles) || miles <= 0) { setZipRadiusStatus('Enter radius > 0.', true); return; }
      const meters = miles * 1609.344;
      try {
        const pt = new Point({ longitude: centroid.x, latitude: centroid.y, spatialReference: { wkid:4326 } });
        const buffer = geometryEngine.geodesicBuffer(pt, miles, 'miles');
        if (!buffer) { setZipRadiusStatus('Buffer failed.', true); return; }
        if (!selectGraphicsLayer) {
          require(["esri/layers/GraphicsLayer"], function(GraphicsLayer){
            selectGraphicsLayer = new GraphicsLayer();
            view.map.add(selectGraphicsLayer);
            addBufferGraphic();
          });
        } else {
          addBufferGraphic();
        }
        function addBufferGraphic() {
          if (!selectGraphicsLayer) return;
            selectGraphicsLayer.graphics.removeMany(selectGraphicsLayer.graphics.toArray());
          const g = new Graphic({ geometry: buffer, symbol: { type:'simple-fill', color:[0,120,255,0.08], outline:{ color:[0,120,255,1], width:2 } } });
          selectGraphicsLayer.add(g);
        }
        await view.goTo({ target: buffer.extent.expand(1.2) }).catch(()=>{});
        setZipRadiusStatus(`Centered on ${zip} (± ${miles.toFixed(2)} mi). Selecting…`);
        await selectFeaturesInGeometry(buffer);
        setZipRadiusStatus(`Completed selection at ${zip}.`);
        updateAdvSelStatus('Selection updated via ZIP radius.');
        console.log('[ZIP Radius] Done', { zip, miles });
      } catch (e) {
        console.error('[ZIP Radius] Error', e);
        setZipRadiusStatus('Error performing selection.', true);
      }
    }

    if (btnZipRadiusGo) {
      btnZipRadiusGo.addEventListener('click', () => {
        const zipVal = zipSelectInput.value;
        const milesVal = zipRadiusInput.value || '10';
        selectByZipRadius(zipVal, milesVal);
      });
    }

    const btnActivatePointCenter = document.getElementById('btnActivatePointCenter');
    const btnPointRadiusGo = document.getElementById('btnPointRadiusGo');
    const btnClearPointCenter = document.getElementById('btnClearPointCenter');
    const pointRadiusInput = document.getElementById('pointRadiusInput');
    const pointRadiusStatus = document.getElementById('pointRadiusStatus');
    let pointCenter = null;
    let pointCenterGraphic = null;
    let pointCenterClickHandle = null;

    function setPointRadiusStatus(msg, isError=false) {
      if (!pointRadiusStatus) return;
      pointRadiusStatus.style.color = isError ? '#b00000' : '#555';
      pointRadiusStatus.textContent = msg;
    }

    function activatePointCenterMode() {
      if (!view) return;
      if (pointCenterClickHandle) { pointCenterClickHandle.remove(); pointCenterClickHandle = null; }
      setPointRadiusStatus('Click anywhere on the map to set center…');
      pointCenterClickHandle = view.on('click', (event) => {
        let mapPoint = event.mapPoint;
        if (!mapPoint && view.toMap) {
          try { mapPoint = view.toMap({ x: event.x, y: event.y }); } catch(_) {}
        }
        if (mapPoint) {
          try {
            pointCenter = new Point({ longitude: mapPoint.longitude, latitude: mapPoint.latitude, spatialReference:{ wkid:4326 } });
          } catch(e) {
            pointCenter = { type:'point', longitude: mapPoint.longitude, latitude: mapPoint.latitude, spatialReference:{ wkid:4326 } };
          }
          setPointRadiusStatus(`Center set at (${mapPoint.longitude.toFixed(4)}, ${mapPoint.latitude.toFixed(4)}). Enter miles and click Go.`);
          addOrUpdatePointCenterGraphic();
          pointCenterClickHandle.remove();
          pointCenterClickHandle = null;
          console.log('[PointRadius] Center chosen via free map click', pointCenter);
        } else {
          setPointRadiusStatus('Could not determine map location from click. Try again.', true);
        }
      });
    }

    function addOrUpdatePointCenterGraphic() {
      if (!pointCenter) return;
      require(["esri/layers/GraphicsLayer"], function(GraphicsLayer){
        if (!selectGraphicsLayer) {
          selectGraphicsLayer = new GraphicsLayer();
          view.map.add(selectGraphicsLayer);
        }
        if (pointCenterGraphic) selectGraphicsLayer.remove(pointCenterGraphic);
        pointCenterGraphic = new Graphic({
          geometry: pointCenter,
          symbol: { type:'simple-marker', color:[255,140,0,0.9], size:10, outline:{ color:'#222', width:1.5 } }
        });
        selectGraphicsLayer.add(pointCenterGraphic);
      });
    }

    async function runPointRadiusSelection() {
      if (!pointCenter) { setPointRadiusStatus('Set a center first (Activate → click a point).', true); return; }
      const milesVal = parseFloat(pointRadiusInput.value || '10');
      if (isNaN(milesVal) || milesVal <= 0) { setPointRadiusStatus('Enter radius > 0.', true); return; }
      try {
        console.log('[PointRadius] Attempting buffer', { pointCenter, miles: milesVal });
        const buffer = geometryEngine.geodesicBuffer(pointCenter, milesVal, 'miles');
        if (!buffer) { setPointRadiusStatus('Buffer failed.', true); return; }
        // Draw buffer (replace previous buffer but keep center marker)
        require(["esri/layers/GraphicsLayer"], function(GraphicsLayer){
          if (!selectGraphicsLayer) {
            selectGraphicsLayer = new GraphicsLayer();
            view.map.add(selectGraphicsLayer);
          }
          const toRemove = selectGraphicsLayer.graphics.toArray().filter(gr => gr.geometry && gr.geometry.type === 'polygon');
          if (toRemove.length) selectGraphicsLayer.graphics.removeMany(toRemove);
          const polyGraphic = new Graphic({ geometry: buffer, symbol:{ type:'simple-fill', color:[0,120,255,0.08], outline:{ color:[0,120,255,1], width:2 } } });
          selectGraphicsLayer.add(polyGraphic);
        });
        await view.goTo({ target: buffer.extent.expand(1.15) }).catch(()=>{});
        setPointRadiusStatus(`Selecting within ${milesVal.toFixed(2)} mi…`);
        await selectFeaturesInGeometry(buffer);
        setPointRadiusStatus(`Completed selection (${milesVal.toFixed(2)} mi).`);
        updateAdvSelStatus('Selection updated via point radius.');
        console.log('[PointRadius] Done', { miles: milesVal, buffer });
      } catch(e) {
        console.error('[PointRadius] Error', e);
        setPointRadiusStatus('Error during selection.', true);
      }
    }

    function clearPointCenter() {
      pointCenter = null;
      setPointRadiusStatus('Center & selection cleared.');
      if (pointCenterGraphic && selectGraphicsLayer) {
        selectGraphicsLayer.remove(pointCenterGraphic);
        pointCenterGraphic = null;
      }
      // Remove buffer polygons
      if (selectGraphicsLayer) {
        const polys = selectGraphicsLayer.graphics.toArray().filter(gr => gr.geometry && gr.geometry.type === 'polygon');
        if (polys.length) selectGraphicsLayer.graphics.removeMany(polys);
      }
      if (selectHighlightHandle) {
        try { selectHighlightHandle.remove(); } catch(_) {}
        selectHighlightHandle = null;
      }
      window._lastSelectedFeatures = { professionals: [], blue: [] };
      const advStatus = document.getElementById('advancedSelectionStatus');
      if (advStatus) advStatus.textContent = 'Selection cleared.';
      console.log('[PointRadius] Center and selection fully cleared');
    }

    if (btnActivatePointCenter) btnActivatePointCenter.addEventListener('click', activatePointCenterMode);
    if (btnPointRadiusGo) btnPointRadiusGo.addEventListener('click', runPointRadiusSelection);
    if (btnClearPointCenter) btnClearPointCenter.addEventListener('click', clearPointCenter);

function activateSelectMode(mode) {
  if (!view) return;
  if ((professionalsLayerRef && !professionalsLayerRef.visible) && (!blueTrianglesLayerRef || !blueTrianglesLayerRef.visible)) {
    updateAdvSelStatus('No selectable layers are visible. Turn on a layer to use selection tools.');
    return;
  }
  if (selectGraphicsLayer) {
    view.map.remove(selectGraphicsLayer);
    selectGraphicsLayer = null;
  }
  if (selectDragHandler) {
    selectDragHandler.remove();
    selectDragHandler = null;
  }
  if (selectHighlightHandle) {
      selectHighlightHandle.remove();
    selectHighlightHandle = null;
  }
  selectLassoPoints = [];
  require(["esri/layers/GraphicsLayer", "esri/Graphic"], function(GraphicsLayer, Graphic) {
    selectGraphicsLayer = new GraphicsLayer();
    view.map.add(selectGraphicsLayer);
    if (mode === 'square') {
      let startPoint = null;
      let rectGraphic = null;
      selectDragHandler = view.on("drag", function(event) {
        event.stopPropagation();
        if (event.action === "start") {
          startPoint = view.toMap({ x: event.x, y: event.y });
          if (rectGraphic) selectGraphicsLayer.remove(rectGraphic);
          rectGraphic = null;
        } else if (event.action === "update" && startPoint) {
          const currPoint = view.toMap({ x: event.x, y: event.y });
          const xmin = Math.min(startPoint.longitude, currPoint.longitude);
          const xmax = Math.max(startPoint.longitude, currPoint.longitude);
          const ymin = Math.min(startPoint.latitude, currPoint.latitude);
          const ymax = Math.max(startPoint.latitude, currPoint.latitude);
          const polygon = {
            type: "polygon",
            rings: [
              [xmin, ymin], [xmax, ymin], [xmax, ymax], [xmin, ymax], [xmin, ymin]
            ],
            spatialReference: { wkid: 4326 }
          };
          if (rectGraphic) selectGraphicsLayer.remove(rectGraphic);
          rectGraphic = new Graphic({
            geometry: polygon,
            symbol: { type: "simple-fill", color: [0, 120, 255, 0.1], outline: { color: [0,120,255,1], width: 2 } }
          });
          selectGraphicsLayer.add(rectGraphic);
        } else if (event.action === "end" && startPoint && rectGraphic) {
          selectFeaturesInGeometry(rectGraphic.geometry);
          startPoint = null;
        }
      });
    } else if (mode === 'lasso') {
      let lassoGraphic = null;
      selectDragHandler = view.on("drag", function(event) {
        event.stopPropagation();
        if (event.action === "start") {
          selectLassoPoints = [view.toMap({ x: event.x, y: event.y })];
          if (lassoGraphic) selectGraphicsLayer.remove(lassoGraphic);
          lassoGraphic = null;
        } else if (event.action === "update") {
          selectLassoPoints.push(view.toMap({ x: event.x, y: event.y }));
          if (lassoGraphic) selectGraphicsLayer.remove(lassoGraphic);
          const rings = selectLassoPoints.map(pt => [pt.longitude, pt.latitude]);
          if (rings.length > 2) rings.push(rings[0]);
          const polygon = {
            type: "polygon",
            rings: rings,
            spatialReference: { wkid: 4326 }
          };
          lassoGraphic = new Graphic({
            geometry: polygon,
            symbol: { type: "simple-fill", color: [0, 120, 255, 0.1], outline: { color: [0,120,255,1], width: 2 } }
          });
          selectGraphicsLayer.add(lassoGraphic);
        } else if (event.action === "end" && selectLassoPoints.length > 2) {
          const rings = selectLassoPoints.map(pt => [pt.longitude, pt.latitude]);
          rings.push(rings[0]);
          const polygon = {
            type: "polygon",
            rings: rings,
            spatialReference: { wkid: 4326 }
          };
          if (lassoGraphic) selectGraphicsLayer.remove(lassoGraphic);
          lassoGraphic = new Graphic({
            geometry: polygon,
            symbol: { type: "simple-fill", color: [0, 120, 255, 0.1], outline: { color: [0,120,255,1], width: 2 } }
          });
          selectGraphicsLayer.add(lassoGraphic);
          selectFeaturesInGeometry(polygon);
          selectLassoPoints = [];
        }
      });
    }
  });
}

    async function selectFeaturesInGeometry(geometry) {
      const layers = [
        { ref: professionalsLayerRef, data: professionalsData, key: 'professionals' },
        { ref: blueTrianglesLayerRef, data: blueTrianglesData, key: 'blue' }
      ];
      if (selectHighlightHandle) selectHighlightHandle.remove();
  let highlightHandles = [];
  let selectedFeatures = { professionals: [], blue: [] };
      for (const layer of layers) {
        if (!layer.ref) continue;
        if (!layer.ref.visible) continue; 
        try {
          let query = {
            geometry: geometry,
            spatialRelationship: "intersects",
            returnGeometry: false,
            outFields: ["*"]
          };
          if (layer.ref.definitionExpression) {
            query.where = layer.ref.definitionExpression;
          }
          const result = await layer.ref.queryFeatures(query);
          if (result.features.length) {
            const layerView = await view.whenLayerView(layer.ref);
            const oids = result.features.map(f => f.attributes.ObjectID);
            highlightHandles.push(layerView.highlight(oids));
            if (Array.isArray(layer.data)) {
              selectedFeatures[layer.key] = layer.data.filter(f => oids.includes(f.attributes.ObjectID));
            }
          }
        } catch (e) {
        }
      }
      const profCount = selectedFeatures.professionals.length;
      const blueCount = selectedFeatures.blue.length;
      if (highlightHandles.length) {
        selectHighlightHandle = {
          remove: () => highlightHandles.forEach(h => h && h.remove()),
          selectedFeatures: selectedFeatures
        };
        window._lastSelectedFeatures = selectedFeatures;
      } else {
        selectHighlightHandle = null;
        window._lastSelectedFeatures = { professionals: [], blue: [] };
      }
      const advStatus = document.getElementById('advancedSelectionStatus');
      if (advStatus) {
        advStatus.textContent = `Selected Professionals: ${profCount}${blueTrianglesLayerRef && blueTrianglesLayerRef.visible ? ` | Blue Triangles: ${blueCount}` : ''}`;
      }
      console.log('[AdvancedSelection] Selection result', { professionals: profCount, blueTriangles: blueCount });
    }

    function resetFilterState() {
      filterState = {
        roleCategories: new Set(),
        parentCompanies: new Set(),
        enabledRoles: new Set(),
        enabledCompanies: new Set()
      };
    }
    function updateLegend() {
      let html = '<div style="font-weight:bold; font-size:17px; margin-bottom:10px; color:#1a3a5b;">Legend</div>';
      if (professionalsLayerRef && professionalsLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#034d46;">Water Treatment Professionals</span><br>';
        const roleColors = {
          "Construction, Installation, and Maintenance": "#FFA910",
          "Engineering & Technical Design or Advisor": "#FFFF01",
          "Field Service and Water Treatment": "#FF0000",
          "Finance and Accounting": "#DBFF78",
          "Leadership and management (non-Sales)": "#80B1D3",
          "Logistics, Delivery, and Warehousing": "#FDB462",
          "Manufacturing and Assembly": "#FFB2D3",
          "Other": "#E1E1E1",
          "Quality": "#4EEAD9",
          "Quality/Sampling/Laboratory": "#BC808D",
          "Sales and Account Management": "#4CE600",
          "Regulatory and EHS": "#F7F7F7",
          "Role Not Mapped": "#DE23D8",
          "Sylmar Group, SWT": "#030303",
        };
        Object.entries(roleColors).forEach(([role, color]) => {
          html += `<span style='display:inline-block; width:16px; height:16px; background:${color}; border:2px solid #000; border-radius:50%; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'>${role}</span><br>`;
        });
        html += '</div>';
      }
      if (blueTrianglesLayerRef && blueTrianglesLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#003366;">Water Facilities</span><br>';
        html += `<span style='display:inline-block; width:0; height:0; border-left:9px solid transparent; border-right:9px solid transparent; border-bottom:18px solid #0074D9; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'></span><br>`;
        html += '</div>';
      }
      
      if (countiesLayerRef && countiesLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#222;">US Counties</span><br>';
        let renderer = countiesLayerRef.renderer;
        let steps = [];
        if (renderer && renderer.uniqueValueInfos && renderer.uniqueValueInfos.length > 0) {
          let countMap = {};
          renderer.uniqueValueInfos.forEach(info => {
            let match = info.label && info.label.match(/\((\d+)\)$/);
            let count = match ? parseInt(match[1]) : 0;
            if (!isNaN(count)) {
              if (!countMap[count]) countMap[count] = [];
              countMap[count].push(info.symbol.color);
            }
          });
          let sortedCounts = Object.keys(countMap).map(Number).sort((a,b)=>a-b);
          let displayCounts = [];
          if (sortedCounts.length > 6) {
            let n = sortedCounts.length;
            displayCounts = [sortedCounts[0]];
            for (let i=1; i<=4; i++) {
              let idx = Math.round(i*n/5)-1;
              if (idx < 0) idx = 0;
              if (idx >= n) idx = n-1;
              let val = sortedCounts[idx];
              if (!displayCounts.includes(val)) displayCounts.push(val);
            }
            if (!displayCounts.includes(sortedCounts[n-1])) displayCounts.push(sortedCounts[n-1]);
            displayCounts = Array.from(new Set(displayCounts)).sort((a,b)=>a-b);
          } else {
            displayCounts = sortedCounts;
          }
          displayCounts.forEach(count => {
            let color = countMap[count][0];
            let rgb = Array.isArray(color) ? `rgb(${color[0]},${color[1]},${color[2]})` : color;
            html += `<span style='display:inline-block; width:18px; height:18px; background:${rgb}; border:1px solid #000; margin-right:6px; vertical-align: middle;'></span> <span style='vertical-align: middle;'>${count} professional${count!==1?'s':''}</span><br>`;
          });
        } else {
          html += `<span style='display:inline-block; width:18px; height:18px; background:rgba(240,240,240,0.1); border:1px solid #000; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'>No Data</span><br>`;
        }
        html += '</div>';
      }
      if (postalCodesLayerRef && postalCodesLayerRef.visible) {
        html += '<div style="margin-bottom:8px;"><span style="font-weight:bold; color:#222;">USA Postal Codes</span><br>';
        html += `<span style='display:inline-block; width:18px; height:18px; background:rgba(0,0,0,0); border:2px solid #98E600; margin-right:6px; vertical-align:middle;'></span> <span style='vertical-align:middle;'>ZIP Code Boundaries</span><br>`;
        html += '</div>';
      }
      if (html === '' || html.indexOf('margin-bottom:8px;') === -1) {
        html += '<div style="color:#888;">No active layers to show in legend.</div>';
      }
      mapLegend.innerHTML = html;
    }

    legendBtn.addEventListener("click", function() {
      const isHidden = (mapLegend.style.display === 'none' || mapLegend.style.display === '');
      if (isHidden) {
        updateLegend();
        mapLegend.style.display = 'block';
      } else {
        mapLegend.style.display = 'none';
      }
    });


    function attachLayerToggle(id, refGetter) {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('change', (e) => {
        const lr = refGetter();
        if (lr) lr.visible = e.target.checked;
        if (mapLegend && mapLegend.style.display === 'block') updateLegend();
      });
    }
    attachLayerToggle('chkProfessionals', () => professionalsLayerRef);
    attachLayerToggle('chkCounties', () => countiesLayerRef);
    attachLayerToggle('chkPostalCodes', () => postalCodesLayerRef);
  attachLayerToggle('chkBlueTriangles', () => blueTrianglesLayerRef);
  }); 
  </script>
</body>

</html>

